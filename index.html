<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LA Metro Bus Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
            color: #fff;
            touch-action: none;
        }
        
        #gameContainer {
            text-align: center;
            max-width: 100vw;
        }
        
        #header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
            padding: 0 10px;
        }
        
        #title {
            font-size: 36px;
            font-weight: bold;
            color: #E16710;
            text-align: left;
        }
        
        #score {
            font-size: 20px;
            color: #E16710;
            text-align: right;
        }
        
        #canvas {
            border: 4px solid #E16710;
            background: #1a1a1a;
            display: block;
            margin: 0 auto;
            max-width: 100vw;
            max-height: 80vh;
        }
        
        #gameOver {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #000;
            border: 4px solid #E16710;
            padding: 30px;
            text-align: center;
        }
        
        #gameOver h1 {
            color: #E16710;
            font-size: 36px;
            margin-bottom: 20px;
        }
        
        #gameOver p {
            font-size: 20px;
            margin: 10px 0;
        }
        
        #restartBtn {
            margin-top: 20px;
            padding: 15px 30px;
            font-size: 20px;
            background: #E16710;
            color: #000;
            border: none;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-weight: bold;
        }
        
        #restartBtn:active {
            background: #c75509;
        }
        
        .high-scores {
            margin-top: 20px;
            font-size: 16px;
            color: #ffaa00;
        }
        
        #instructions {
            margin-top: 10px;
            font-size: 14px;
            color: #888;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="header">
            <div id="title">BUSSS</div>
            <div id="score">SCORE: 0</div>
        </div>
        <canvas id="canvas"></canvas>
        <div id="instructions">Swipe to change direction • Pick up passengers • Drop off at stops</div>
    </div>
    
    <div id="gameOver">
        <h1>GAME OVER</h1>
        <p id="finalScore"></p>
        <div class="high-scores" id="highScores"></div>
        <button id="restartBtn">PLAY AGAIN</button>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        // Set canvas size
        const gridSize = 20;
        const canvasSize = Math.min(window.innerWidth - 20, window.innerHeight - 150, 600);
        canvas.width = canvasSize;
        canvas.height = canvasSize;
        const tileCount = Math.floor(canvasSize / gridSize);
        
        // Game state
        let bus = [];
        let direction = { x: 1, y: 0 };
        let nextDirection = { x: 1, y: 0 };
        let passengers = [];
        let busStops = [];
        let score = 0;
        let gameRunning = false;
        let gameLoop;
        let passengersPickedUp = 0;
        let gameSpeed = 150;
        
        // Touch controls
        let touchStartX = 0;
        let touchStartY = 0;
        
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
        }, { passive: false });
        
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
        }, { passive: false });
        
        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            if (!gameRunning) return;
            
            const touchEndX = e.changedTouches[0].clientX;
            const touchEndY = e.changedTouches[0].clientY;
            
            const deltaX = touchEndX - touchStartX;
            const deltaY = touchEndY - touchStartY;
            
            // Determine swipe direction
            if (Math.abs(deltaX) > Math.abs(deltaY)) {
                // Horizontal swipe
                if (deltaX > 30 && direction.x === 0) {
                    nextDirection = { x: 1, y: 0 };
                } else if (deltaX < -30 && direction.x === 0) {
                    nextDirection = { x: -1, y: 0 };
                }
            } else {
                // Vertical swipe
                if (deltaY > 30 && direction.y === 0) {
                    nextDirection = { x: 0, y: 1 };
                } else if (deltaY < -30 && direction.y === 0) {
                    nextDirection = { x: 0, y: -1 };
                }
            }
        }, { passive: false });
        
        // Keyboard controls for desktop testing
        document.addEventListener('keydown', (e) => {
            if (!gameRunning) return;
            
            switch(e.key) {
                case 'ArrowUp':
                    if (direction.y === 0) nextDirection = { x: 0, y: -1 };
                    break;
                case 'ArrowDown':
                    if (direction.y === 0) nextDirection = { x: 0, y: 1 };
                    break;
                case 'ArrowLeft':
                    if (direction.x === 0) nextDirection = { x: -1, y: 0 };
                    break;
                case 'ArrowRight':
                    if (direction.x === 0) nextDirection = { x: 1, y: 0 };
                    break;
            }
        });
        
        function initGame() {
            bus = [
                { x: Math.floor(tileCount / 2), y: Math.floor(tileCount / 2) },
                { x: Math.floor(tileCount / 2) - 1, y: Math.floor(tileCount / 2) }
            ];
            direction = { x: 1, y: 0 };
            nextDirection = { x: 1, y: 0 };
            score = 0;
            passengers = [];
            busStops = [];
            gameRunning = true;
            passengersPickedUp = 0;
            gameSpeed = 150;
            
            spawnPassenger();
            
            document.getElementById('gameOver').style.display = 'none';
            updateScore();
            
            if (gameLoop) clearInterval(gameLoop);
            gameLoop = setInterval(update, gameSpeed);
        }
        
        function spawnPassenger() {
            const bodyColors = ['#0072BC', '#EB131B', '#58A738']; // blue, red, green
            const headColors = ['#F5DEB3', '#E8C9A1', '#D4A76A']; // light, medium, dark beige
            
            let newPassenger;
            do {
                newPassenger = {
                    x: Math.floor(Math.random() * tileCount),
                    y: Math.floor(Math.random() * tileCount),
                    type: Math.floor(Math.random() * 3), // 0, 1, or 2 for three variations
                    bodyColor: bodyColors[Math.floor(Math.random() * bodyColors.length)],
                    headColor: headColors[Math.floor(Math.random() * headColors.length)]
                };
            } while (isOnBus(newPassenger.x, newPassenger.y));
            
            passengers.push(newPassenger);
        }
        
        function spawnBusStop() {
            // Only spawn if 7 passengers picked up, bus is long enough, and max 2 stops
            if (passengersPickedUp >= 7 && bus.length > 3 && busStops.length < 2) {
                let newStop;
                do {
                    newStop = {
                        x: Math.floor(Math.random() * tileCount),
                        y: Math.floor(Math.random() * tileCount)
                    };
                } while (isOnBus(newStop.x, newStop.y) || isOnPassenger(newStop.x, newStop.y));
                
                busStops.push(newStop);
                passengersPickedUp = 0; // Reset counter after spawning stop
            }
        }
        
        function isOnBus(x, y) {
            return bus.some(segment => segment.x === x && segment.y === y);
        }
        
        function isOnPassenger(x, y) {
            return passengers.some(p => p.x === x && p.y === y);
        }
        
        function update() {
            if (!gameRunning) return;
            
            direction = { ...nextDirection };
            
            // Move bus
            const head = { x: bus[0].x + direction.x, y: bus[0].y + direction.y };
            
            // Wrap around walls
            if (head.x < 0) head.x = tileCount - 1;
            if (head.x >= tileCount) head.x = 0;
            if (head.y < 0) head.y = tileCount - 1;
            if (head.y >= tileCount) head.y = 0;
            
            // Check collision with self
            if (isOnBus(head.x, head.y)) {
                endGame();
                return;
            }
            
            bus.unshift(head);
            
            // Check passenger pickup
            let pickedUp = false;
            passengers = passengers.filter(passenger => {
                if (passenger.x === head.x && passenger.y === head.y) {
                    const oldScore = score;
                    score += 10;
                    pickedUp = true;
                    passengersPickedUp++;
                    
                    // Speed up every 100 points
                    if (Math.floor(score / 100) > Math.floor(oldScore / 100)) {
                        gameSpeed = Math.max(50, gameSpeed - 15); // Don't go faster than 50ms
                        clearInterval(gameLoop);
                        gameLoop = setInterval(update, gameSpeed);
                    }
                    
                    return false;
                }
                return true;
            });
            
            if (pickedUp) {
                spawnPassenger();
                spawnBusStop();
            } else {
                bus.pop(); // Remove tail if no passenger picked up
            }
            
            // Check bus stop
            busStops = busStops.filter(stop => {
                if (stop.x === head.x && stop.y === head.y) {
                    // Drop off passengers - shrink bus
                    if (bus.length > 3) {
                        const dropOff = Math.min(3, bus.length - 3);
                        for (let i = 0; i < dropOff; i++) {
                            bus.pop();
                        }
                        score += dropOff * 15;
                    }
                    return false;
                }
                return true;
            });
            
            updateScore();
            draw();
        }
        
        function draw() {
            // Clear canvas
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw grid
            ctx.strokeStyle = '#2a2a2a';
            ctx.lineWidth = 1;
            for (let i = 0; i <= tileCount; i++) {
                ctx.beginPath();
                ctx.moveTo(i * gridSize, 0);
                ctx.lineTo(i * gridSize, canvas.height);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(0, i * gridSize);
                ctx.lineTo(canvas.width, i * gridSize);
                ctx.stroke();
            }
            
            // Draw bus
            bus.forEach((segment, index) => {
                if (index === 0) {
                    // Bus head (front) with windshield and bumper
                    ctx.fillStyle = '#E16710';
                    ctx.fillRect(
                        segment.x * gridSize + 1,
                        segment.y * gridSize + 1,
                        gridSize - 2,
                        gridSize - 2
                    );
                    
                    // Blue windshield (top third)
                    ctx.fillStyle = '#33CCFF';
                    ctx.fillRect(
                        segment.x * gridSize + 1,
                        segment.y * gridSize + 1,
                        gridSize - 2,
                        (gridSize - 2) / 3
                    );
                    
                    // Gray bumper (bottom quarter)
                    ctx.fillStyle = '#ADB8BF';
                    ctx.fillRect(
                        segment.x * gridSize + 1,
                        segment.y * gridSize + gridSize - 1 - (gridSize - 2) / 4,
                        gridSize - 2,
                        (gridSize - 2) / 4
                    );
                } else if (index === bus.length - 1) {
                    // Bus back with gray rectangle on bottom third
                    ctx.fillStyle = '#E16710';
                    ctx.fillRect(
                        segment.x * gridSize + 1,
                        segment.y * gridSize + 1,
                        gridSize - 2,
                        gridSize - 2
                    );
                    
                    // Gray rectangle on bottom third
                    ctx.fillStyle = '#ADB8BF';
                    ctx.fillRect(
                        segment.x * gridSize + 1,
                        segment.y * gridSize + gridSize - 1 - (gridSize - 2) / 3,
                        gridSize - 2,
                        (gridSize - 2) / 3
                    );
                } else {
                    // Middle bus segments
                    ctx.fillStyle = '#E16710';
                    ctx.fillRect(
                        segment.x * gridSize + 1,
                        segment.y * gridSize + 1,
                        gridSize - 2,
                        gridSize - 2
                    );
                    
                    // Add blue windows to make it look like a bus
                    ctx.fillStyle = '#33CCFF';
                    ctx.fillRect(
                        segment.x * gridSize + 4,
                        segment.y * gridSize + 4,
                        4,
                        4
                    );
                    ctx.fillRect(
                        segment.x * gridSize + gridSize - 8,
                        segment.y * gridSize + 4,
                        4,
                        4
                    );
                }
            });
            
            // Draw passengers (three variations with colored heads and bodies)
            passengers.forEach(passenger => {
                const px = passenger.x * gridSize;
                const py = passenger.y * gridSize;
                
                if (passenger.type === 0) {
                    // Type 0: Tall person - small head, larger body
                    ctx.fillStyle = passenger.headColor;
                    ctx.fillRect(px + 7, py + 3, 6, 5); // head
                    ctx.fillStyle = passenger.bodyColor;
                    ctx.fillRect(px + 5, py + 9, 10, 9); // body
                } else if (passenger.type === 1) {
                    // Type 1: Wide person - wider body
                    ctx.fillStyle = passenger.headColor;
                    ctx.fillRect(px + 7, py + 4, 6, 5); // head
                    ctx.fillStyle = passenger.bodyColor;
                    ctx.fillRect(px + 4, py + 10, 12, 8); // body
                } else {
                    // Type 2: Short person - similar size head and body
                    ctx.fillStyle = passenger.headColor;
                    ctx.fillRect(px + 7, py + 5, 6, 6); // head
                    ctx.fillStyle = passenger.bodyColor;
                    ctx.fillRect(px + 6, py + 12, 8, 6); // body
                }
            });
            
            // Draw bus stops with circle and M logo
            busStops.forEach(stop => {
                // Outer square
                ctx.fillStyle = '#0072BC';
                ctx.fillRect(
                    stop.x * gridSize + 2,
                    stop.y * gridSize + 2,
                    gridSize - 4,
                    gridSize - 4
                );
                
                // Inner circle
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(
                    stop.x * gridSize + gridSize / 2,
                    stop.y * gridSize + gridSize / 2,
                    gridSize / 3,
                    0,
                    Math.PI * 2
                );
                ctx.fill();
                
                // M letter
                ctx.fillStyle = '#0072BC';
                ctx.font = 'bold 12px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('M', stop.x * gridSize + gridSize / 2, stop.y * gridSize + gridSize / 2);
            });
        }
        
        function updateScore() {
            document.getElementById('score').textContent = `SCORE: ${score}`;
        }
        
        function endGame() {
            gameRunning = false;
            clearInterval(gameLoop);
            
            // Save high scores
            let highScores = JSON.parse(localStorage.getItem('metroHighScores') || '[]');
            highScores.push(score);
            highScores.sort((a, b) => b - a);
            highScores = highScores.slice(0, 3);
            localStorage.setItem('metroHighScores', JSON.stringify(highScores));
            
            // Display game over
            document.getElementById('finalScore').textContent = `YOUR SCORE: ${score}`;
            
            let highScoresHTML = '<h3>TOP SCORES</h3>';
            highScores.forEach((s, i) => {
                highScoresHTML += `<p>${i + 1}. ${s}</p>`;
            });
            document.getElementById('highScores').innerHTML = highScoresHTML;
            
            document.getElementById('gameOver').style.display = 'block';
        }
        
        document.getElementById('restartBtn').addEventListener('click', initGame);
        
        // Start game
        initGame();
    </script>
</body>
</html>
