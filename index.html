<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LA Metro Bus Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
            color: #fff;
            touch-action: none;
        }
        
        #gameContainer {
            text-align: center;
            max-width: 100vw;
        }
        
        #header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            max-width: 375px;
            margin-left: auto;
            margin-right: auto;
            padding: 0 10px;
        }
        
        #title {
            font-size: 36px;
            font-weight: bold;
            color: #E16710;
            text-align: left;
        }
        
        #score {
            font-size: 20px;
            color: #E16710;
            text-align: right;
        }
        
        #canvas {
            border: 4px solid #E16710;
            background: #1a1a1a;
            display: block;
            margin: 0 auto;
            max-width: 100vw;
            max-height: 85vh;
        }
        
        #gameOver {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #000;
            border: 4px solid #E16710;
            padding: 30px;
            text-align: center;
        }
        
        #gameOver h1 {
            color: #E16710;
            font-size: 36px;
            margin-bottom: 20px;
        }
        
        #gameOver p {
            font-size: 20px;
            margin: 10px 0;
        }
        
        #restartBtn {
            margin-top: 20px;
            padding: 15px 30px;
            font-size: 20px;
            background: #E16710;
            color: #000;
            border: none;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-weight: bold;
        }
        
        #restartBtn:active {
            background: #c75509;
        }
        
        .high-scores {
            margin-top: 20px;
            font-size: 16px;
            color: #ffaa00;
        }
        
        #instructions {
            margin-top: 10px;
            font-size: 14px;
            color: #888;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="header">
            <div id="title">BUSSS</div>
            <div id="score">SCORE: 0</div>
        </div>
        <canvas id="canvas"></canvas>
        <div id="instructions">Swipe to change direction ‚Ä¢ Pick up passengers ‚Ä¢ Drop off at stops</div>
    </div>
    
    <div id="gameOver">
        <h1>GAME OVER</h1>
        <p id="finalScore"></p>
        <div class="high-scores" id="highScores"></div>
        <button id="restartBtn">PLAY AGAIN</button>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Set canvas size - portrait orientation for mobile
        const gridSize = 25;
        const canvasWidth = 375;
        const canvasHeight = 625;
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;
        const tileCountX = Math.floor(canvasWidth / gridSize);
        const tileCountY = Math.floor(canvasHeight / gridSize);

        // Game state
        let bus = [];
        let direction = { x: 1, y: 0 };
        let nextDirection = { x: 1, y: 0 };
        let passengers = [];
        let busStops = [];
        let score = 0;
        let gameRunning = false;
        let gameLoop;
        let passengersPickedUp = 0;
        let gameSpeed = 150;

        // Construction zone state
        let constructionZone = null;
        let constructionBlinkState = true;
        let constructionBlinkTimer = null;
        let constructionPassengerCount = 0; // Passengers picked up since construction appeared
        let constructionFading = false;
        let constructionFadeOpacity = 1;
        let constructionShowCheckmark = false;
        let constructionCompleted = true; // Tracks if previous zone was completed (starts true so first zone can spawn)
        let futureConstructionZone = null; // Pre-determined location for next construction zone
        let passengersUntilConstruction = 7; // Countdown to next construction (starts at 7 after completion)

        // Passenger emojis - full figure standing people
        const passengerEmojis = ['üßç', 'üßç‚Äç‚ôÇÔ∏è', 'üßç‚Äç‚ôÄÔ∏è'];
        
        // Audio context for sound effects
        let audioContext = null;
        let coinSoundPlaying = false;
        let dingDongPlaying = false;

        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
        }

        function playCoinSound() {
            if (!audioContext || coinSoundPlaying) return;

            coinSoundPlaying = true;

            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            // Create a pleasant coin chime effect
            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(987.77, audioContext.currentTime); // B5
            oscillator.frequency.setValueAtTime(1318.51, audioContext.currentTime + 0.08); // E6

            // Quick fade in and out for a clean sound
            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(0.3, audioContext.currentTime + 0.02);
            gainNode.gain.linearRampToValueAtTime(0.2, audioContext.currentTime + 0.08);
            gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.15);

            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.15);

            // Allow next sound after this one finishes
            setTimeout(() => {
                coinSoundPlaying = false;
            }, 100);
        }

        function playDingDongSound() {
            if (!audioContext || dingDongPlaying) return;

            dingDongPlaying = true;

            // First tone - "ding" (higher pitch)
            const oscillator1 = audioContext.createOscillator();
            const gainNode1 = audioContext.createGain();
            oscillator1.connect(gainNode1);
            gainNode1.connect(audioContext.destination);
            oscillator1.type = 'sine';
            oscillator1.frequency.setValueAtTime(830.61, audioContext.currentTime); // G#5
            gainNode1.gain.setValueAtTime(0, audioContext.currentTime);
            gainNode1.gain.linearRampToValueAtTime(0.35, audioContext.currentTime + 0.02);
            gainNode1.gain.linearRampToValueAtTime(0.25, audioContext.currentTime + 0.15);
            gainNode1.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.3);
            oscillator1.start(audioContext.currentTime);
            oscillator1.stop(audioContext.currentTime + 0.3);

            // Second tone - "dong" (lower pitch, starts slightly after)
            const oscillator2 = audioContext.createOscillator();
            const gainNode2 = audioContext.createGain();
            oscillator2.connect(gainNode2);
            gainNode2.connect(audioContext.destination);
            oscillator2.type = 'sine';
            oscillator2.frequency.setValueAtTime(622.25, audioContext.currentTime + 0.15); // D#5
            gainNode2.gain.setValueAtTime(0, audioContext.currentTime + 0.15);
            gainNode2.gain.linearRampToValueAtTime(0.35, audioContext.currentTime + 0.17);
            gainNode2.gain.linearRampToValueAtTime(0.25, audioContext.currentTime + 0.3);
            gainNode2.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.5);
            oscillator2.start(audioContext.currentTime + 0.15);
            oscillator2.stop(audioContext.currentTime + 0.5);

            // Allow next sound after this one finishes
            setTimeout(() => {
                dingDongPlaying = false;
            }, 400);
        }

        // Touch controls
        let touchStartX = 0;
        let touchStartY = 0;
        
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            initAudio();
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
        }, { passive: false });
        
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
        }, { passive: false });
        
        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            if (!gameRunning) return;
            
            const touchEndX = e.changedTouches[0].clientX;
            const touchEndY = e.changedTouches[0].clientY;
            
            const deltaX = touchEndX - touchStartX;
            const deltaY = touchEndY - touchStartY;
            
            // Determine swipe direction
            if (Math.abs(deltaX) > Math.abs(deltaY)) {
                // Horizontal swipe
                if (deltaX > 30 && direction.x === 0) {
                    nextDirection = { x: 1, y: 0 };
                } else if (deltaX < -30 && direction.x === 0) {
                    nextDirection = { x: -1, y: 0 };
                }
            } else {
                // Vertical swipe
                if (deltaY > 30 && direction.y === 0) {
                    nextDirection = { x: 0, y: 1 };
                } else if (deltaY < -30 && direction.y === 0) {
                    nextDirection = { x: 0, y: -1 };
                }
            }
        }, { passive: false });
        
        // Keyboard controls for desktop testing
        document.addEventListener('keydown', (e) => {
            initAudio();
            if (!gameRunning) return;

            switch(e.key) {
                case 'ArrowUp':
                    if (direction.y === 0) nextDirection = { x: 0, y: -1 };
                    break;
                case 'ArrowDown':
                    if (direction.y === 0) nextDirection = { x: 0, y: 1 };
                    break;
                case 'ArrowLeft':
                    if (direction.x === 0) nextDirection = { x: -1, y: 0 };
                    break;
                case 'ArrowRight':
                    if (direction.x === 0) nextDirection = { x: 1, y: 0 };
                    break;
            }
        });
        
        function initGame() {
            bus = [
                { x: Math.floor(tileCountX / 2), y: Math.floor(tileCountY / 2) },
                { x: Math.floor(tileCountX / 2) - 1, y: Math.floor(tileCountY / 2) }
            ];
            direction = { x: 1, y: 0 };
            nextDirection = { x: 1, y: 0 };
            score = 0;
            passengers = [];
            busStops = [];
            gameRunning = true;
            passengersPickedUp = 0;
            gameSpeed = 150;

            // Reset construction zone
            constructionZone = null;
            constructionPassengerCount = 0;
            constructionFading = false;
            constructionFadeOpacity = 1;
            constructionShowCheckmark = false;
            constructionCompleted = true;
            futureConstructionZone = null;
            passengersUntilConstruction = 7;
            if (constructionBlinkTimer) clearInterval(constructionBlinkTimer);
            constructionBlinkTimer = setInterval(() => {
                constructionBlinkState = !constructionBlinkState;
            }, 300);

            // Spawn 3-4 passengers initially
            const initialPassengers = 3 + Math.floor(Math.random() * 2);
            for (let i = 0; i < initialPassengers; i++) {
                spawnPassenger();
            }

            document.getElementById('gameOver').style.display = 'none';
            updateScore();

            if (gameLoop) clearInterval(gameLoop);
            gameLoop = setInterval(update, gameSpeed);
        }
        
        function spawnPassenger() {
            let newPassenger;
            let attempts = 0;
            do {
                newPassenger = {
                    x: Math.floor(Math.random() * tileCountX),
                    y: Math.floor(Math.random() * tileCountY),
                    emoji: passengerEmojis[Math.floor(Math.random() * passengerEmojis.length)]
                };
                attempts++;
            } while ((isOnBus(newPassenger.x, newPassenger.y) ||
                     isOnPassenger(newPassenger.x, newPassenger.y) ||
                     isOnBusStop(newPassenger.x, newPassenger.y) ||
                     isOnConstruction(newPassenger.x, newPassenger.y)) && attempts < 100);

            if (attempts < 100) {
                passengers.push(newPassenger);
            }
        }

        function isOnBusStop(x, y) {
            return busStops.some(stop => stop.x === x && stop.y === y);
        }

        function isOnConstruction(x, y) {
            if (!constructionZone || constructionFading) return false;
            return x >= constructionZone.x && x < constructionZone.x + 3 &&
                   y >= constructionZone.y && y < constructionZone.y + 3;
        }

        function spawnConstructionZone() {
            if (constructionZone || constructionFading) return;

            // Use pre-determined future location if available
            if (futureConstructionZone) {
                constructionZone = futureConstructionZone;
                futureConstructionZone = null;
                constructionPassengerCount = 0;
                constructionCompleted = false;
                return;
            }

            let attempts = 0;
            let zone;
            do {
                zone = {
                    x: Math.floor(Math.random() * (tileCountX - 3)),
                    y: Math.floor(Math.random() * (tileCountY - 3))
                };
                attempts++;
            } while (isConstructionOverlapping(zone) && attempts < 100);

            if (attempts < 100) {
                constructionZone = zone;
                constructionPassengerCount = 0;
                constructionCompleted = false;
            }
        }

        function pickFutureConstructionLocation() {
            if (futureConstructionZone) return; // Already picked

            let attempts = 0;
            let zone;
            do {
                zone = {
                    x: Math.floor(Math.random() * (tileCountX - 3)),
                    y: Math.floor(Math.random() * (tileCountY - 3))
                };
                attempts++;
            } while (isConstructionOverlapping(zone) && attempts < 100);

            if (attempts < 100) {
                futureConstructionZone = zone;
            }
        }

        function isConstructionOverlapping(zone) {
            // Check all 3x3 cells of the zone
            for (let dx = 0; dx < 3; dx++) {
                for (let dy = 0; dy < 3; dy++) {
                    const x = zone.x + dx;
                    const y = zone.y + dy;
                    if (isOnBus(x, y) || isOnPassenger(x, y) || isOnBusStop(x, y)) {
                        return true;
                    }
                }
            }
            return false;
        }

        function startConstructionFade() {
            constructionShowCheckmark = true;
            constructionFading = true;

            // Show checkmark for 0.5 seconds
            setTimeout(() => {
                constructionShowCheckmark = false;
                // Start fade out
                const fadeInterval = setInterval(() => {
                    constructionFadeOpacity -= 0.1;
                    if (constructionFadeOpacity <= 0) {
                        clearInterval(fadeInterval);
                        constructionZone = null;
                        constructionFading = false;
                        constructionFadeOpacity = 1;
                        constructionCompleted = true;
                        passengersUntilConstruction = 7; // Reset countdown for next construction
                    }
                }, 50);
            }, 500);
        }
        
        function spawnBusStop() {
            // Only spawn if 7 passengers picked up, bus is long enough, and max 2 stops
            if (passengersPickedUp >= 7 && bus.length > 3 && busStops.length < 2) {
                let newStop;
                let attempts = 0;
                do {
                    newStop = {
                        x: Math.floor(Math.random() * tileCountX),
                        y: Math.floor(Math.random() * tileCountY)
                    };
                    attempts++;
                } while ((isOnBus(newStop.x, newStop.y) ||
                         isOnPassenger(newStop.x, newStop.y) ||
                         isOnConstruction(newStop.x, newStop.y)) && attempts < 100);

                if (attempts < 100) {
                    busStops.push(newStop);
                    passengersPickedUp = 0; // Reset counter after spawning stop
                }
            }
        }
        
        function isOnBus(x, y) {
            return bus.some(segment => segment.x === x && segment.y === y);
        }
        
        function isOnPassenger(x, y) {
            return passengers.some(p => p.x === x && p.y === y);
        }
        
        function update() {
            if (!gameRunning) return;

            direction = { ...nextDirection };

            // Move bus
            const head = { x: bus[0].x + direction.x, y: bus[0].y + direction.y };

            // Wrap around walls (portrait canvas)
            if (head.x < 0) head.x = tileCountX - 1;
            if (head.x >= tileCountX) head.x = 0;
            if (head.y < 0) head.y = tileCountY - 1;
            if (head.y >= tileCountY) head.y = 0;

            // Check collision with self
            if (isOnBus(head.x, head.y)) {
                endGame();
                return;
            }

            // Check collision with construction zone
            if (isOnConstruction(head.x, head.y)) {
                endGame();
                return;
            }

            bus.unshift(head);

            // Check passenger pickup
            let pickedUp = false;
            passengers = passengers.filter(passenger => {
                if (passenger.x === head.x && passenger.y === head.y) {
                    const oldScore = score;
                    score += 10;
                    pickedUp = true;
                    passengersPickedUp++;

                    // Track passengers for construction zone removal
                    if (constructionZone && !constructionFading) {
                        constructionPassengerCount++;
                        if (constructionPassengerCount >= 4) {
                            startConstructionFade();
                        }
                    }

                    // Speed up every 100 points
                    if (Math.floor(score / 100) > Math.floor(oldScore / 100)) {
                        gameSpeed = Math.max(50, gameSpeed - 15); // Don't go faster than 50ms
                        clearInterval(gameLoop);
                        gameLoop = setInterval(update, gameSpeed);
                    }

                    return false;
                }
                return true;
            });

            if (pickedUp) {
                playCoinSound();

                // Maintain 3-4 passengers on screen
                while (passengers.length < 3) {
                    spawnPassenger();
                }

                // Construction zone spawning logic - only after previous completed AND 7 passengers
                if (constructionCompleted && !constructionZone && !constructionFading) {
                    passengersUntilConstruction--;

                    // At 3 passengers remaining, pick the future location
                    if (passengersUntilConstruction === 3 && !futureConstructionZone) {
                        pickFutureConstructionLocation();
                    }

                    // When countdown reaches 0, spawn the construction zone
                    if (passengersUntilConstruction <= 0) {
                        spawnConstructionZone();
                    }
                }

                spawnBusStop();
            } else {
                bus.pop(); // Remove tail if no passenger picked up
            }

            // Check bus stop
            busStops = busStops.filter(stop => {
                if (stop.x === head.x && stop.y === head.y) {
                    // Drop off passengers - shrink bus
                    if (bus.length > 3) {
                        const dropOff = Math.min(3, bus.length - 3);
                        for (let i = 0; i < dropOff; i++) {
                            bus.pop();
                        }
                        score += dropOff * 15;
                        playDingDongSound();
                    }
                    return false;
                }
                return true;
            });

            updateScore();
            draw();
        }
        
        function draw() {
            // Clear canvas
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw grid (portrait canvas)
            ctx.strokeStyle = '#2a2a2a';
            ctx.lineWidth = 1;
            for (let i = 0; i <= tileCountX; i++) {
                ctx.beginPath();
                ctx.moveTo(i * gridSize, 0);
                ctx.lineTo(i * gridSize, canvas.height);
                ctx.stroke();
            }
            for (let i = 0; i <= tileCountY; i++) {
                ctx.beginPath();
                ctx.moveTo(0, i * gridSize);
                ctx.lineTo(canvas.width, i * gridSize);
                ctx.stroke();
            }

            // Draw construction countdown warning (if future zone is picked and countdown is 3 or less)
            if (futureConstructionZone && passengersUntilConstruction <= 3 && passengersUntilConstruction > 0) {
                const zoneX = futureConstructionZone.x * gridSize;
                const zoneY = futureConstructionZone.y * gridSize;
                const zoneSize = 3 * gridSize;

                // Choose color based on countdown
                let bgColor;
                if (passengersUntilConstruction === 3) {
                    bgColor = 'rgba(255, 200, 0, 0.6)'; // Yellow/caution
                } else if (passengersUntilConstruction === 2) {
                    bgColor = 'rgba(255, 140, 0, 0.7)'; // Orange
                } else {
                    bgColor = 'rgba(255, 60, 60, 0.8)'; // Red
                }

                // Draw full 3x3 highlighted background
                ctx.fillStyle = bgColor;
                ctx.fillRect(zoneX, zoneY, zoneSize, zoneSize);

                // Draw border around the zone
                ctx.strokeStyle = passengersUntilConstruction === 1 ? '#ff3333' :
                                  passengersUntilConstruction === 2 ? '#ff8c00' : '#ffcc00';
                ctx.lineWidth = 3;
                ctx.strokeRect(zoneX + 1.5, zoneY + 1.5, zoneSize - 3, zoneSize - 3);

                // Draw countdown number in center
                ctx.font = 'bold 40px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = '#fff';
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 3;
                const centerX = zoneX + zoneSize / 2;
                const centerY = zoneY + zoneSize / 2;
                ctx.strokeText(passengersUntilConstruction.toString(), centerX, centerY);
                ctx.fillText(passengersUntilConstruction.toString(), centerX, centerY);
            }

            // Draw construction zone (if active)
            if (constructionZone) {
                const constructionEmojis = ['üöß', 'üèóÔ∏è', '‚ö†Ô∏è'];
                ctx.globalAlpha = constructionFadeOpacity;

                if (constructionShowCheckmark) {
                    // Show green checkmark
                    ctx.font = '60px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    const centerX = (constructionZone.x + 1.5) * gridSize;
                    const centerY = (constructionZone.y + 1.5) * gridSize;
                    ctx.fillText('‚úÖ', centerX, centerY);
                } else {
                    // Draw 3x3 construction zone with mixed emojis
                    ctx.font = '20px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';

                    for (let dx = 0; dx < 3; dx++) {
                        for (let dy = 0; dy < 3; dy++) {
                            const x = (constructionZone.x + dx) * gridSize + gridSize / 2;
                            const y = (constructionZone.y + dy) * gridSize + gridSize / 2;

                            // Blinking effect - alternate visibility
                            if (constructionBlinkState || (dx + dy) % 2 === 0) {
                                const emojiIndex = (dx + dy * 3) % constructionEmojis.length;
                                ctx.fillText(constructionEmojis[emojiIndex], x, y);
                            }
                        }
                    }
                }
                ctx.globalAlpha = 1;
            }

            // Draw bus (pixel art style - kept as-is)
            bus.forEach((segment, index) => {
                if (index === 0) {
                    // Bus head (front) with windshield and bumper
                    ctx.fillStyle = '#E16710';
                    ctx.fillRect(
                        segment.x * gridSize + 1,
                        segment.y * gridSize + 1,
                        gridSize - 2,
                        gridSize - 2
                    );

                    // Blue windshield (top third)
                    ctx.fillStyle = '#33CCFF';
                    ctx.fillRect(
                        segment.x * gridSize + 2,
                        segment.y * gridSize + 2,
                        gridSize - 4,
                        (gridSize - 4) / 3
                    );

                    // Gray bumper (bottom quarter)
                    ctx.fillStyle = '#ADB8BF';
                    ctx.fillRect(
                        segment.x * gridSize + 2,
                        segment.y * gridSize + gridSize - 2 - (gridSize - 4) / 4,
                        gridSize - 4,
                        (gridSize - 4) / 4
                    );
                } else if (index === bus.length - 1) {
                    // Bus back with gray rectangle on bottom third
                    ctx.fillStyle = '#E16710';
                    ctx.fillRect(
                        segment.x * gridSize + 1,
                        segment.y * gridSize + 1,
                        gridSize - 2,
                        gridSize - 2
                    );

                    // Gray rectangle on bottom third
                    ctx.fillStyle = '#ADB8BF';
                    ctx.fillRect(
                        segment.x * gridSize + 2,
                        segment.y * gridSize + gridSize - 2 - (gridSize - 4) / 3,
                        gridSize - 4,
                        (gridSize - 4) / 3
                    );
                } else {
                    // Middle bus segments
                    ctx.fillStyle = '#E16710';
                    ctx.fillRect(
                        segment.x * gridSize + 1,
                        segment.y * gridSize + 1,
                        gridSize - 2,
                        gridSize - 2
                    );

                    // Add blue windows to make it look like a bus (adjusted for 25px grid)
                    ctx.fillStyle = '#33CCFF';
                    ctx.fillRect(
                        segment.x * gridSize + 5,
                        segment.y * gridSize + 5,
                        5,
                        5
                    );
                    ctx.fillRect(
                        segment.x * gridSize + gridSize - 10,
                        segment.y * gridSize + 5,
                        5,
                        5
                    );
                }
            });

            // Draw passengers using emojis
            ctx.font = '20px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            passengers.forEach(passenger => {
                const px = passenger.x * gridSize + gridSize / 2;
                const py = passenger.y * gridSize + gridSize / 2;
                ctx.fillText(passenger.emoji, px, py);
            });

            // Draw bus stops using üöè emoji
            ctx.font = '22px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            busStops.forEach(stop => {
                const sx = stop.x * gridSize + gridSize / 2;
                const sy = stop.y * gridSize + gridSize / 2;
                ctx.fillText('üöè', sx, sy);
            });
        }
        
        function updateScore() {
            document.getElementById('score').textContent = `SCORE: ${score}`;
        }
        
        function endGame() {
            gameRunning = false;
            clearInterval(gameLoop);
            if (constructionBlinkTimer) clearInterval(constructionBlinkTimer);
            
            // Save high scores
            let highScores = JSON.parse(localStorage.getItem('metroHighScores') || '[]');
            highScores.push(score);
            highScores.sort((a, b) => b - a);
            highScores = highScores.slice(0, 3);
            localStorage.setItem('metroHighScores', JSON.stringify(highScores));
            
            // Display game over
            document.getElementById('finalScore').textContent = `YOUR SCORE: ${score}`;
            
            let highScoresHTML = '<h3>TOP SCORES</h3>';
            highScores.forEach((s, i) => {
                highScoresHTML += `<p>${i + 1}. ${s}</p>`;
            });
            document.getElementById('highScores').innerHTML = highScoresHTML;
            
            document.getElementById('gameOver').style.display = 'block';
        }
        
        document.getElementById('restartBtn').addEventListener('click', initGame);
        
        // Start game
        initGame();
    </script>
</body>
</html>
