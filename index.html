<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LA Metro Bus Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
            color: #fff;
            touch-action: none;
        }
        
        #gameContainer {
            text-align: center;
            max-width: 100vw;
        }
        
        #header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            max-width: 375px;
            margin-left: auto;
            margin-right: auto;
            padding: 0 10px;
        }
        
        #title {
            font-size: 36px;
            font-weight: bold;
            color: #E16710;
            text-align: left;
        }
        
        #score {
            font-size: 20px;
            color: #E16710;
            text-align: right;
        }
        
        #canvas {
            border: 4px solid #E16710;
            background: #1a1a1a;
            display: block;
            margin: 0 auto;
            max-width: 100vw;
            max-height: 85vh;
        }
        
        #gameOver {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #000;
            border: 4px solid #E16710;
            padding: 30px;
            text-align: center;
        }
        
        #gameOver h1 {
            color: #E16710;
            font-size: 36px;
            margin-bottom: 20px;
        }
        
        #gameOver p {
            font-size: 20px;
            margin: 10px 0;
        }
        
        #restartBtn {
            margin-top: 20px;
            padding: 15px 30px;
            font-size: 20px;
            background: #E16710;
            color: #000;
            border: none;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-weight: bold;
        }
        
        #restartBtn:active {
            background: #c75509;
        }
        
        .high-scores {
            margin-top: 20px;
            font-size: 16px;
            color: #ffaa00;
        }
        
        #instructions {
            margin-top: 10px;
            font-size: 14px;
            color: #888;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="header">
            <div id="title">BUSSS</div>
            <div id="score">SCORE: 0</div>
        </div>
        <canvas id="canvas"></canvas>
        <div id="instructions">Swipe to change direction â€¢ Pick up passengers â€¢ Drop off at stops</div>
    </div>
    
    <div id="gameOver">
        <h1>GAME OVER</h1>
        <p id="finalScore"></p>
        <div class="high-scores" id="highScores"></div>
        <button id="restartBtn">PLAY AGAIN</button>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Set canvas size - portrait orientation for mobile
        const gridSize = 25;
        const canvasWidth = 375;
        const canvasHeight = 625;
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;
        const tileCountX = Math.floor(canvasWidth / gridSize);
        const tileCountY = Math.floor(canvasHeight / gridSize);

        // Game state
        let bus = [];
        let direction = { x: 1, y: 0 };
        let nextDirection = { x: 1, y: 0 };
        let passengers = [];
        let busStops = [];
        let score = 0;
        let gameRunning = false;
        let gameLoop;
        let passengersPickedUp = 0;
        let passengersForConstruction = 0; // Tracks passengers for construction spawn
        let gameSpeed = 150;

        // Construction zone state
        let constructionZone = null;
        let constructionBlinkState = true;
        let constructionBlinkTimer = null;
        let constructionPassengerCount = 0; // Passengers picked up since construction appeared
        let constructionFading = false;
        let constructionFadeOpacity = 1;
        let constructionShowCheckmark = false;

        // Passenger emojis - full figure standing people
        const passengerEmojis = ['ðŸ§', 'ðŸ§â€â™‚ï¸', 'ðŸ§â€â™€ï¸'];
        
        // Audio context for sound effects
        let audioContext = null;
        let coinSoundPlaying = false;

        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
        }

        function playCoinSound() {
            if (!audioContext || coinSoundPlaying) return;

            coinSoundPlaying = true;

            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            // Create a pleasant coin chime effect
            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(987.77, audioContext.currentTime); // B5
            oscillator.frequency.setValueAtTime(1318.51, audioContext.currentTime + 0.08); // E6

            // Quick fade in and out for a clean sound
            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(0.3, audioContext.currentTime + 0.02);
            gainNode.gain.linearRampToValueAtTime(0.2, audioContext.currentTime + 0.08);
            gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.15);

            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.15);

            // Allow next sound after this one finishes
            setTimeout(() => {
                coinSoundPlaying = false;
            }, 100);
        }

        // Touch controls
        let touchStartX = 0;
        let touchStartY = 0;
        
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            initAudio();
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
        }, { passive: false });
        
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
        }, { passive: false });
        
        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            if (!gameRunning) return;
            
            const touchEndX = e.changedTouches[0].clientX;
            const touchEndY = e.changedTouches[0].clientY;
            
            const deltaX = touchEndX - touchStartX;
            const deltaY = touchEndY - touchStartY;
            
            // Determine swipe direction
            if (Math.abs(deltaX) > Math.abs(deltaY)) {
                // Horizontal swipe
                if (deltaX > 30 && direction.x === 0) {
                    nextDirection = { x: 1, y: 0 };
                } else if (deltaX < -30 && direction.x === 0) {
                    nextDirection = { x: -1, y: 0 };
                }
            } else {
                // Vertical swipe
                if (deltaY > 30 && direction.y === 0) {
                    nextDirection = { x: 0, y: 1 };
                } else if (deltaY < -30 && direction.y === 0) {
                    nextDirection = { x: 0, y: -1 };
                }
            }
        }, { passive: false });
        
        // Keyboard controls for desktop testing
        document.addEventListener('keydown', (e) => {
            initAudio();
            if (!gameRunning) return;

            switch(e.key) {
                case 'ArrowUp':
                    if (direction.y === 0) nextDirection = { x: 0, y: -1 };
                    break;
                case 'ArrowDown':
                    if (direction.y === 0) nextDirection = { x: 0, y: 1 };
                    break;
                case 'ArrowLeft':
                    if (direction.x === 0) nextDirection = { x: -1, y: 0 };
                    break;
                case 'ArrowRight':
                    if (direction.x === 0) nextDirection = { x: 1, y: 0 };
                    break;
            }
        });
        
        function initGame() {
            bus = [
                { x: Math.floor(tileCountX / 2), y: Math.floor(tileCountY / 2) },
                { x: Math.floor(tileCountX / 2) - 1, y: Math.floor(tileCountY / 2) }
            ];
            direction = { x: 1, y: 0 };
            nextDirection = { x: 1, y: 0 };
            score = 0;
            passengers = [];
            busStops = [];
            gameRunning = true;
            passengersPickedUp = 0;
            passengersForConstruction = 0;
            gameSpeed = 150;

            // Reset construction zone
            constructionZone = null;
            constructionPassengerCount = 0;
            constructionFading = false;
            constructionFadeOpacity = 1;
            constructionShowCheckmark = false;
            if (constructionBlinkTimer) clearInterval(constructionBlinkTimer);
            constructionBlinkTimer = setInterval(() => {
                constructionBlinkState = !constructionBlinkState;
            }, 300);

            // Spawn 3-4 passengers initially
            const initialPassengers = 3 + Math.floor(Math.random() * 2);
            for (let i = 0; i < initialPassengers; i++) {
                spawnPassenger();
            }

            document.getElementById('gameOver').style.display = 'none';
            updateScore();

            if (gameLoop) clearInterval(gameLoop);
            gameLoop = setInterval(update, gameSpeed);
        }
        
        function spawnPassenger() {
            let newPassenger;
            let attempts = 0;
            do {
                newPassenger = {
                    x: Math.floor(Math.random() * tileCountX),
                    y: Math.floor(Math.random() * tileCountY),
                    emoji: passengerEmojis[Math.floor(Math.random() * passengerEmojis.length)]
                };
                attempts++;
            } while ((isOnBus(newPassenger.x, newPassenger.y) ||
                     isOnPassenger(newPassenger.x, newPassenger.y) ||
                     isOnBusStop(newPassenger.x, newPassenger.y) ||
                     isOnConstruction(newPassenger.x, newPassenger.y)) && attempts < 100);

            if (attempts < 100) {
                passengers.push(newPassenger);
            }
        }

        function isOnBusStop(x, y) {
            return busStops.some(stop => stop.x === x && stop.y === y);
        }

        function isOnConstruction(x, y) {
            if (!constructionZone || constructionFading) return false;
            return x >= constructionZone.x && x < constructionZone.x + 4 &&
                   y >= constructionZone.y && y < constructionZone.y + 4;
        }

        function spawnConstructionZone() {
            if (constructionZone || constructionFading) return;

            let attempts = 0;
            let zone;
            do {
                zone = {
                    x: Math.floor(Math.random() * (tileCountX - 4)),
                    y: Math.floor(Math.random() * (tileCountY - 4))
                };
                attempts++;
            } while (isConstructionOverlapping(zone) && attempts < 100);

            if (attempts < 100) {
                constructionZone = zone;
                constructionPassengerCount = 0;
            }
        }

        function isConstructionOverlapping(zone) {
            // Check all 4x4 cells of the zone
            for (let dx = 0; dx < 4; dx++) {
                for (let dy = 0; dy < 4; dy++) {
                    const x = zone.x + dx;
                    const y = zone.y + dy;
                    if (isOnBus(x, y) || isOnPassenger(x, y) || isOnBusStop(x, y)) {
                        return true;
                    }
                }
            }
            return false;
        }

        function startConstructionFade() {
            constructionShowCheckmark = true;
            constructionFading = true;

            // Show checkmark for 0.5 seconds
            setTimeout(() => {
                constructionShowCheckmark = false;
                // Start fade out
                const fadeInterval = setInterval(() => {
                    constructionFadeOpacity -= 0.1;
                    if (constructionFadeOpacity <= 0) {
                        clearInterval(fadeInterval);
                        constructionZone = null;
                        constructionFading = false;
                        constructionFadeOpacity = 1;
                    }
                }, 50);
            }, 500);
        }
        
        function spawnBusStop() {
            // Only spawn if 7 passengers picked up, bus is long enough, and max 2 stops
            if (passengersPickedUp >= 7 && bus.length > 3 && busStops.length < 2) {
                let newStop;
                let attempts = 0;
                do {
                    newStop = {
                        x: Math.floor(Math.random() * tileCountX),
                        y: Math.floor(Math.random() * tileCountY)
                    };
                    attempts++;
                } while ((isOnBus(newStop.x, newStop.y) ||
                         isOnPassenger(newStop.x, newStop.y) ||
                         isOnConstruction(newStop.x, newStop.y)) && attempts < 100);

                if (attempts < 100) {
                    busStops.push(newStop);
                    passengersPickedUp = 0; // Reset counter after spawning stop
                }
            }
        }
        
        function isOnBus(x, y) {
            return bus.some(segment => segment.x === x && segment.y === y);
        }
        
        function isOnPassenger(x, y) {
            return passengers.some(p => p.x === x && p.y === y);
        }
        
        function update() {
            if (!gameRunning) return;

            direction = { ...nextDirection };

            // Move bus
            const head = { x: bus[0].x + direction.x, y: bus[0].y + direction.y };

            // Wrap around walls (portrait canvas)
            if (head.x < 0) head.x = tileCountX - 1;
            if (head.x >= tileCountX) head.x = 0;
            if (head.y < 0) head.y = tileCountY - 1;
            if (head.y >= tileCountY) head.y = 0;

            // Check collision with self
            if (isOnBus(head.x, head.y)) {
                endGame();
                return;
            }

            // Check collision with construction zone
            if (isOnConstruction(head.x, head.y)) {
                endGame();
                return;
            }

            bus.unshift(head);

            // Check passenger pickup
            let pickedUp = false;
            passengers = passengers.filter(passenger => {
                if (passenger.x === head.x && passenger.y === head.y) {
                    const oldScore = score;
                    score += 10;
                    pickedUp = true;
                    passengersPickedUp++;
                    passengersForConstruction++;

                    // Track passengers for construction zone removal
                    if (constructionZone && !constructionFading) {
                        constructionPassengerCount++;
                        if (constructionPassengerCount >= 4) {
                            startConstructionFade();
                        }
                    }

                    // Speed up every 100 points
                    if (Math.floor(score / 100) > Math.floor(oldScore / 100)) {
                        gameSpeed = Math.max(50, gameSpeed - 15); // Don't go faster than 50ms
                        clearInterval(gameLoop);
                        gameLoop = setInterval(update, gameSpeed);
                    }

                    return false;
                }
                return true;
            });

            if (pickedUp) {
                playCoinSound();

                // Maintain 3-4 passengers on screen
                while (passengers.length < 3) {
                    spawnPassenger();
                }

                // Spawn construction zone after 5 passengers (if none active)
                if (passengersForConstruction >= 5 && !constructionZone && !constructionFading) {
                    spawnConstructionZone();
                    passengersForConstruction = 0;
                }

                spawnBusStop();
            } else {
                bus.pop(); // Remove tail if no passenger picked up
            }

            // Check bus stop
            busStops = busStops.filter(stop => {
                if (stop.x === head.x && stop.y === head.y) {
                    // Drop off passengers - shrink bus
                    if (bus.length > 3) {
                        const dropOff = Math.min(3, bus.length - 3);
                        for (let i = 0; i < dropOff; i++) {
                            bus.pop();
                        }
                        score += dropOff * 15;
                    }
                    return false;
                }
                return true;
            });

            updateScore();
            draw();
        }
        
        function draw() {
            // Clear canvas
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw grid (portrait canvas)
            ctx.strokeStyle = '#2a2a2a';
            ctx.lineWidth = 1;
            for (let i = 0; i <= tileCountX; i++) {
                ctx.beginPath();
                ctx.moveTo(i * gridSize, 0);
                ctx.lineTo(i * gridSize, canvas.height);
                ctx.stroke();
            }
            for (let i = 0; i <= tileCountY; i++) {
                ctx.beginPath();
                ctx.moveTo(0, i * gridSize);
                ctx.lineTo(canvas.width, i * gridSize);
                ctx.stroke();
            }

            // Draw construction zone (if active)
            if (constructionZone) {
                const constructionEmojis = ['ðŸš§', 'ðŸ—ï¸', 'âš ï¸'];
                ctx.globalAlpha = constructionFadeOpacity;

                if (constructionShowCheckmark) {
                    // Show green checkmark
                    ctx.font = '80px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    const centerX = (constructionZone.x + 2) * gridSize;
                    const centerY = (constructionZone.y + 2) * gridSize;
                    ctx.fillText('âœ…', centerX, centerY);
                } else {
                    // Draw 4x4 construction zone with mixed emojis
                    ctx.font = '20px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';

                    for (let dx = 0; dx < 4; dx++) {
                        for (let dy = 0; dy < 4; dy++) {
                            const x = (constructionZone.x + dx) * gridSize + gridSize / 2;
                            const y = (constructionZone.y + dy) * gridSize + gridSize / 2;

                            // Blinking effect - alternate visibility
                            if (constructionBlinkState || (dx + dy) % 2 === 0) {
                                const emojiIndex = (dx + dy * 4) % constructionEmojis.length;
                                ctx.fillText(constructionEmojis[emojiIndex], x, y);
                            }
                        }
                    }
                }
                ctx.globalAlpha = 1;
            }

            // Draw bus (pixel art style - kept as-is)
            bus.forEach((segment, index) => {
                if (index === 0) {
                    // Bus head (front) with windshield and bumper
                    ctx.fillStyle = '#E16710';
                    ctx.fillRect(
                        segment.x * gridSize + 1,
                        segment.y * gridSize + 1,
                        gridSize - 2,
                        gridSize - 2
                    );

                    // Blue windshield (top third)
                    ctx.fillStyle = '#33CCFF';
                    ctx.fillRect(
                        segment.x * gridSize + 2,
                        segment.y * gridSize + 2,
                        gridSize - 4,
                        (gridSize - 4) / 3
                    );

                    // Gray bumper (bottom quarter)
                    ctx.fillStyle = '#ADB8BF';
                    ctx.fillRect(
                        segment.x * gridSize + 2,
                        segment.y * gridSize + gridSize - 2 - (gridSize - 4) / 4,
                        gridSize - 4,
                        (gridSize - 4) / 4
                    );
                } else if (index === bus.length - 1) {
                    // Bus back with gray rectangle on bottom third
                    ctx.fillStyle = '#E16710';
                    ctx.fillRect(
                        segment.x * gridSize + 1,
                        segment.y * gridSize + 1,
                        gridSize - 2,
                        gridSize - 2
                    );

                    // Gray rectangle on bottom third
                    ctx.fillStyle = '#ADB8BF';
                    ctx.fillRect(
                        segment.x * gridSize + 2,
                        segment.y * gridSize + gridSize - 2 - (gridSize - 4) / 3,
                        gridSize - 4,
                        (gridSize - 4) / 3
                    );
                } else {
                    // Middle bus segments
                    ctx.fillStyle = '#E16710';
                    ctx.fillRect(
                        segment.x * gridSize + 1,
                        segment.y * gridSize + 1,
                        gridSize - 2,
                        gridSize - 2
                    );

                    // Add blue windows to make it look like a bus (adjusted for 25px grid)
                    ctx.fillStyle = '#33CCFF';
                    ctx.fillRect(
                        segment.x * gridSize + 5,
                        segment.y * gridSize + 5,
                        5,
                        5
                    );
                    ctx.fillRect(
                        segment.x * gridSize + gridSize - 10,
                        segment.y * gridSize + 5,
                        5,
                        5
                    );
                }
            });

            // Draw passengers using emojis
            ctx.font = '20px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            passengers.forEach(passenger => {
                const px = passenger.x * gridSize + gridSize / 2;
                const py = passenger.y * gridSize + gridSize / 2;
                ctx.fillText(passenger.emoji, px, py);
            });

            // Draw bus stops using ðŸš emoji
            ctx.font = '22px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            busStops.forEach(stop => {
                const sx = stop.x * gridSize + gridSize / 2;
                const sy = stop.y * gridSize + gridSize / 2;
                ctx.fillText('ðŸš', sx, sy);
            });
        }
        
        function updateScore() {
            document.getElementById('score').textContent = `SCORE: ${score}`;
        }
        
        function endGame() {
            gameRunning = false;
            clearInterval(gameLoop);
            if (constructionBlinkTimer) clearInterval(constructionBlinkTimer);
            
            // Save high scores
            let highScores = JSON.parse(localStorage.getItem('metroHighScores') || '[]');
            highScores.push(score);
            highScores.sort((a, b) => b - a);
            highScores = highScores.slice(0, 3);
            localStorage.setItem('metroHighScores', JSON.stringify(highScores));
            
            // Display game over
            document.getElementById('finalScore').textContent = `YOUR SCORE: ${score}`;
            
            let highScoresHTML = '<h3>TOP SCORES</h3>';
            highScores.forEach((s, i) => {
                highScoresHTML += `<p>${i + 1}. ${s}</p>`;
            });
            document.getElementById('highScores').innerHTML = highScoresHTML;
            
            document.getElementById('gameOver').style.display = 'block';
        }
        
        document.getElementById('restartBtn').addEventListener('click', initGame);
        
        // Start game
        initGame();
    </script>
</body>
</html>
