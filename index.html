<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Busss - The Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
            color: #fff;
            touch-action: none;
        }
        
        #gameContainer {
            text-align: center;
            max-width: 100vw;
        }
        
        #header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            max-width: 375px;
            margin-left: auto;
            margin-right: auto;
            padding: 0 10px;
        }
        
        #title {
            font-size: 36px;
            font-weight: bold;
            color: #E16710;
            text-align: left;
        }
        
        #neighborhoodName {
            font-size: 14px;
            color: #fff;
            text-align: center;
            background: rgba(0,0,0,0.5);
            padding: 2px 8px;
            border-radius: 4px;
        }

        #score {
            font-size: 20px;
            color: #E16710;
            text-align: right;
        }
        
        #canvas {
            border: none;
            background: #1a1a1a;
            display: block;
            margin: 0 auto;
            max-width: 100vw;
            max-height: 85vh;
        }
        
        #gameOver {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #000;
            border: 4px solid #E16710;
            padding: 30px;
            text-align: center;
        }
        
        #gameOver h1 {
            color: #E16710;
            font-size: 36px;
            margin-bottom: 20px;
        }
        
        #gameOver p {
            font-size: 20px;
            margin: 10px 0;
        }
        
        #restartBtn {
            margin-top: 20px;
            padding: 15px 30px;
            font-size: 20px;
            background: #E16710;
            color: #000;
            border: none;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-weight: bold;
        }
        
        #restartBtn:active {
            background: #c75509;
        }
        
        .high-scores {
            margin-top: 20px;
            font-size: 16px;
            color: #ffaa00;
        }
        
        #startScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        #startScreen img {
            max-width: 98%;
            max-height: 58vh;
            border: none;
            border-radius: 0;
        }

        #startInstructions {
            margin-top: 15px;
            text-align: left;
            padding: 12px 18px;
            background: rgba(225, 103, 16, 0.1);
            border: 2px solid #E16710;
            border-radius: 8px;
            max-width: 350px;
        }

        #startInstructions p {
            margin: 6px 0;
            font-size: 15px;
            color: #fff;
        }

        #tapToStart {
            margin-top: 15px;
            padding: 20px 50px;
            font-size: 28px;
            background: #E16710;
            color: #000;
            border: none;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            border-radius: 8px;
            animation: pulse 1.5s ease-in-out infinite;
        }

        #tapToStart:active {
            background: #c75509;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
    </style>
</head>
<body>
    <div id="startScreen">
        <img src="cover-art-busss.png" alt="BUSSS Cover Art">
        <div id="startInstructions">
            <p>üöå Swipe to change direction</p>
            <p>üßç Pick up passengers</p>
            <p>üöè Drop off at bus stops to shrink bus</p>
            <p>üöß Avoid construction zones</p>
        </div>
        <button id="tapToStart">TAP TO START</button>
    </div>

    <div id="gameContainer">
        <div id="header">
            <div id="title">BUSSS</div>
            <div id="neighborhoodName">DOWNTOWN</div>
            <div id="score">SCORE: 0</div>
        </div>
        <canvas id="canvas"></canvas>
    </div>
    
    <div id="gameOver">
        <h1>GAME OVER</h1>
        <p id="finalScore"></p>
        <div class="high-scores" id="highScores"></div>
        <button id="restartBtn">PLAY AGAIN</button>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Set canvas size - portrait orientation for mobile
        // Hi-DPI support for crisp rendering on retina displays
        const dpr = window.devicePixelRatio || 1;
        const gridSize = 25;
        const canvasWidth = 375;
        const canvasHeight = 625;

        // Set actual canvas dimensions scaled by device pixel ratio
        canvas.width = canvasWidth * dpr;
        canvas.height = canvasHeight * dpr;

        // Set CSS display size (visual size on screen)
        canvas.style.width = canvasWidth + 'px';
        canvas.style.height = canvasHeight + 'px';

        // Scale context to match device pixel ratio for crisp rendering
        ctx.scale(dpr, dpr);

        const tileCountX = Math.floor(canvasWidth / gridSize);
        const tileCountY = Math.floor(canvasHeight / gridSize);

        // Game state
        let bus = [];
        let direction = { x: 1, y: 0 };
        let nextDirection = { x: 1, y: 0 };
        let passengers = [];
        let busStops = [];
        let score = 0;
        let gameRunning = false;
        let gameLoop;
        let passengersPickedUp = 0;
        let gameSpeed = 150;

        // Construction zone state
        let constructionZone = null;
        let constructionPassengerCount = 0; // Passengers picked up since construction appeared
        let constructionFading = false;
        let constructionFadeOpacity = 1;
        let constructionShowCheckmark = false;
        let constructionCompleted = true; // Tracks if previous zone was completed (starts true so first zone can spawn)
        let futureConstructionZone = null; // Pre-determined location for next construction zone
        let passengersUntilConstruction = 7; // Countdown to next construction (starts at 7 after completion)

        // Neighborhood system - 3x3 grid of LA neighborhoods
        const NEIGHBORHOODS = {
            // Row 0 (top)
            '0,0': { name: 'HOLLYWOOD', color: '#4a1942', landmark: 'üé¨' },
            '1,0': { name: 'PASADENA', color: '#1a4a3a', landmark: 'üèõÔ∏è' },
            '2,0': { name: 'VAN NUYS', color: '#3a3a1a', landmark: 'üõ©Ô∏è' },
            // Row 1 (middle)
            '0,1': { name: 'SANTA MONICA', color: '#1a3a4a', landmark: 'üé°' },
            '1,1': { name: 'DOWNTOWN', color: '#2a2a3a', landmark: 'üèôÔ∏è' },
            '2,1': { name: 'EAST LA', color: '#4a2a1a', landmark: 'üåÆ' },
            // Row 2 (bottom)
            '0,2': { name: 'COMPTON', color: '#3a1a3a', landmark: 'üèÄ' },
            '1,2': { name: 'SOUTH CENTRAL', color: '#2a3a2a', landmark: 'üéµ' },
            '2,2': { name: 'LONG BEACH', color: '#1a3a3a', landmark: '‚õ±Ô∏è' }
        };

        // Current neighborhood position (start at Downtown which is center: 1,1)
        let currentNeighborhoodX = 1;
        let currentNeighborhoodY = 1;

        // State for each neighborhood - tracks collected letters, landmark status, passenger count
        let neighborhoodStates = {};

        // L-shaped corner bumpers (3-square L in each corner)
        // Each bumper is an array of {x, y} positions
        const CORNER_BUMPERS = {
            topLeft: [
                {x: 0, y: 0}, {x: 1, y: 0}, {x: 2, y: 0},
                {x: 0, y: 1},
                {x: 0, y: 2}
            ],
            topRight: [
                {x: 12, y: 0}, {x: 13, y: 0}, {x: 14, y: 0},
                {x: 14, y: 1},
                {x: 14, y: 2}
            ],
            bottomLeft: [
                {x: 0, y: 22},
                {x: 0, y: 23},
                {x: 0, y: 24}, {x: 1, y: 24}, {x: 2, y: 24}
            ],
            bottomRight: [
                {x: 14, y: 22},
                {x: 14, y: 23},
                {x: 12, y: 24}, {x: 13, y: 24}, {x: 14, y: 24}
            ]
        };

        // Flatten all bumper positions for collision detection
        function getAllBumperPositions() {
            return [
                ...CORNER_BUMPERS.topLeft,
                ...CORNER_BUMPERS.topRight,
                ...CORNER_BUMPERS.bottomLeft,
                ...CORNER_BUMPERS.bottomRight
            ];
        }

        function isOnBumper(x, y) {
            const bumpers = getAllBumperPositions();
            return bumpers.some(b => b.x === x && b.y === y);
        }

        // Get current neighborhood data
        function getCurrentNeighborhood() {
            return NEIGHBORHOODS[`${currentNeighborhoodX},${currentNeighborhoodY}`];
        }

        // Get current neighborhood state
        function getCurrentNeighborhoodState() {
            const key = `${currentNeighborhoodX},${currentNeighborhoodY}`;
            if (!neighborhoodStates[key]) {
                initNeighborhoodState(key);
            }
            return neighborhoodStates[key];
        }

        // Initialize state for a neighborhood
        function initNeighborhoodState(key) {
            const hood = NEIGHBORHOODS[key];
            const letters = generateLetterPositions(hood.name);
            neighborhoodStates[key] = {
                collectedLetters: new Array(letters.length).fill(false),
                letterPositions: letters,
                landmarkCollected: false,
                passengersPickedUp: 0,
                etchedName: false // Shows etched name after all letters collected
            };
        }

        // Generate positions for neighborhood name letters
        function generateLetterPositions(name) {
            const letters = [];
            const words = name.split(' ');

            // Calculate starting position (centered, avoiding bumpers, corridors, and bus start)
            // Safe area is roughly columns 4-10 and rows 5-19
            // Place letters in upper safe area to avoid bus starting position (7, 12)
            const safeStartX = 4;
            const safeEndX = 10;
            const letterY = 16; // Below center to avoid bus start position

            let currentY = letterY;

            words.forEach((word, wordIndex) => {
                const wordLength = word.length;
                const startX = Math.floor((safeStartX + safeEndX) / 2) - Math.floor(wordLength / 2);

                for (let i = 0; i < word.length; i++) {
                    letters.push({
                        x: startX + i,
                        y: currentY,
                        letter: word[i],
                        isPassenger: i % 2 === 0, // Alternate between passenger and stop
                        collected: false
                    });
                }
                currentY += 2; // Space between word rows
            });

            return letters;
        }

        // Get landmark position for current neighborhood (2x2, centered in safe area)
        function getLandmarkPosition() {
            // Place landmark in upper portion of safe area
            return { x: 6, y: 7 };
        }

        // Check if position is on a letter
        function isOnLetter(x, y) {
            const state = getCurrentNeighborhoodState();
            return state.letterPositions.some((letter, i) =>
                letter.x === x && letter.y === y && !state.collectedLetters[i]
            );
        }

        // Check if position is on landmark (2x2 area)
        function isOnLandmark(x, y) {
            const state = getCurrentNeighborhoodState();
            if (state.landmarkCollected) return false;

            const pos = getLandmarkPosition();
            return x >= pos.x && x < pos.x + 2 && y >= pos.y && y < pos.y + 2;
        }

        // Initialize all neighborhood states
        function initAllNeighborhoodStates() {
            neighborhoodStates = {};
            Object.keys(NEIGHBORHOODS).forEach(key => {
                initNeighborhoodState(key);
            });
        }

        // Passenger emojis - full figure standing people
        const passengerEmojis = ['üßç', 'üßç‚Äç‚ôÇÔ∏è', 'üßç‚Äç‚ôÄÔ∏è'];
        
        // Audio context for sound effects
        let audioContext = null;
        let coinSoundPlaying = false;
        let dingDongPlaying = false;
        let audioInitialized = false;

        function initAudio() {
            if (!audioContext) {
                try {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.warn('Web Audio API not supported');
                    return;
                }
            }
            if (audioContext.state === 'suspended') {
                audioContext.resume().then(() => {
                    audioInitialized = true;
                }).catch(e => console.warn('Audio resume failed:', e));
            } else {
                audioInitialized = true;
            }
        }

        function playCoinSound() {
            // Ensure audio context is initialized
            if (!audioContext) initAudio();
            if (!audioContext || coinSoundPlaying) return;

            // Resume audio context if suspended (browser autoplay policy)
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }

            coinSoundPlaying = true;

            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            // Create a pleasant coin chime effect
            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(987.77, audioContext.currentTime); // B5
            oscillator.frequency.setValueAtTime(1318.51, audioContext.currentTime + 0.08); // E6

            // Quick fade in and out for a clean sound
            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(0.3, audioContext.currentTime + 0.02);
            gainNode.gain.linearRampToValueAtTime(0.2, audioContext.currentTime + 0.08);
            gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.15);

            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.15);

            // Allow next sound after this one finishes
            setTimeout(() => {
                coinSoundPlaying = false;
            }, 100);
        }

        function playDingDongSound() {
            // Ensure audio context is initialized
            if (!audioContext) initAudio();
            if (!audioContext || dingDongPlaying) return;

            // Resume audio context if suspended (browser autoplay policy)
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }

            dingDongPlaying = true;

            // First tone - "ding" (higher pitch)
            const oscillator1 = audioContext.createOscillator();
            const gainNode1 = audioContext.createGain();
            oscillator1.connect(gainNode1);
            gainNode1.connect(audioContext.destination);
            oscillator1.type = 'sine';
            oscillator1.frequency.setValueAtTime(830.61, audioContext.currentTime); // G#5
            gainNode1.gain.setValueAtTime(0, audioContext.currentTime);
            gainNode1.gain.linearRampToValueAtTime(0.35, audioContext.currentTime + 0.02);
            gainNode1.gain.linearRampToValueAtTime(0.25, audioContext.currentTime + 0.15);
            gainNode1.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.3);
            oscillator1.start(audioContext.currentTime);
            oscillator1.stop(audioContext.currentTime + 0.3);

            // Second tone - "dong" (lower pitch, starts slightly after)
            const oscillator2 = audioContext.createOscillator();
            const gainNode2 = audioContext.createGain();
            oscillator2.connect(gainNode2);
            gainNode2.connect(audioContext.destination);
            oscillator2.type = 'sine';
            oscillator2.frequency.setValueAtTime(622.25, audioContext.currentTime + 0.15); // D#5
            gainNode2.gain.setValueAtTime(0, audioContext.currentTime + 0.15);
            gainNode2.gain.linearRampToValueAtTime(0.35, audioContext.currentTime + 0.17);
            gainNode2.gain.linearRampToValueAtTime(0.25, audioContext.currentTime + 0.3);
            gainNode2.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.5);
            oscillator2.start(audioContext.currentTime + 0.15);
            oscillator2.stop(audioContext.currentTime + 0.5);

            // Allow next sound after this one finishes
            setTimeout(() => {
                dingDongPlaying = false;
            }, 400);
        }

        // Touch controls
        let touchStartX = 0;
        let touchStartY = 0;
        
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            initAudio();
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
        }, { passive: false });
        
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
        }, { passive: false });
        
        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            if (!gameRunning) return;
            
            const touchEndX = e.changedTouches[0].clientX;
            const touchEndY = e.changedTouches[0].clientY;
            
            const deltaX = touchEndX - touchStartX;
            const deltaY = touchEndY - touchStartY;
            
            // Determine swipe direction
            if (Math.abs(deltaX) > Math.abs(deltaY)) {
                // Horizontal swipe
                if (deltaX > 30 && direction.x === 0) {
                    nextDirection = { x: 1, y: 0 };
                } else if (deltaX < -30 && direction.x === 0) {
                    nextDirection = { x: -1, y: 0 };
                }
            } else {
                // Vertical swipe
                if (deltaY > 30 && direction.y === 0) {
                    nextDirection = { x: 0, y: 1 };
                } else if (deltaY < -30 && direction.y === 0) {
                    nextDirection = { x: 0, y: -1 };
                }
            }
        }, { passive: false });
        
        // Keyboard controls for desktop testing
        document.addEventListener('keydown', (e) => {
            initAudio();
            if (!gameRunning) return;

            switch(e.key) {
                case 'ArrowUp':
                    if (direction.y === 0) nextDirection = { x: 0, y: -1 };
                    break;
                case 'ArrowDown':
                    if (direction.y === 0) nextDirection = { x: 0, y: 1 };
                    break;
                case 'ArrowLeft':
                    if (direction.x === 0) nextDirection = { x: -1, y: 0 };
                    break;
                case 'ArrowRight':
                    if (direction.x === 0) nextDirection = { x: 1, y: 0 };
                    break;
            }
        });

        // Mouse controls for desktop - initialize audio and handle clicks
        canvas.addEventListener('mousedown', (e) => {
            initAudio();
        });

        canvas.addEventListener('click', (e) => {
            initAudio();
        });

        // Also initialize audio on any document interaction (for desktop browsers)
        document.addEventListener('click', () => {
            initAudio();
        }, { once: true });

        document.addEventListener('mousedown', () => {
            initAudio();
        }, { once: true });
        
        function initGame() {
            bus = [
                { x: Math.floor(tileCountX / 2), y: Math.floor(tileCountY / 2) },
                { x: Math.floor(tileCountX / 2) - 1, y: Math.floor(tileCountY / 2) }
            ];
            direction = { x: 1, y: 0 };
            nextDirection = { x: 1, y: 0 };
            score = 0;
            passengers = [];
            busStops = [];
            gameRunning = true;
            passengersPickedUp = 0;
            gameSpeed = 150;

            // Reset construction zone
            constructionZone = null;
            constructionPassengerCount = 0;
            constructionFading = false;
            constructionFadeOpacity = 1;
            constructionShowCheckmark = false;
            constructionCompleted = true;
            futureConstructionZone = null;
            passengersUntilConstruction = 7;

            // Reset neighborhood state - start in Downtown (center)
            currentNeighborhoodX = 1;
            currentNeighborhoodY = 1;
            initAllNeighborhoodStates();
            updateNeighborhoodDisplay();

            // Spawn 3-4 passengers initially
            const initialPassengers = 3 + Math.floor(Math.random() * 2);
            for (let i = 0; i < initialPassengers; i++) {
                spawnPassenger();
            }

            document.getElementById('gameOver').style.display = 'none';
            updateScore();

            if (gameLoop) clearInterval(gameLoop);
            gameLoop = setInterval(update, gameSpeed);
        }

        function updateNeighborhoodDisplay() {
            const hood = getCurrentNeighborhood();
            document.getElementById('neighborhoodName').textContent = hood.name;
            document.getElementById('neighborhoodName').style.backgroundColor = hood.color;
        }

        // Helper function to lighten a hex color
        function lightenColor(color, percent) {
            const num = parseInt(color.replace('#', ''), 16);
            const amt = Math.round(2.55 * percent);
            const R = Math.min(255, (num >> 16) + amt);
            const G = Math.min(255, ((num >> 8) & 0x00FF) + amt);
            const B = Math.min(255, (num & 0x0000FF) + amt);
            return '#' + (0x1000000 + R * 0x10000 + G * 0x100 + B).toString(16).slice(1);
        }
        
        function spawnPassenger() {
            let newPassenger;
            let attempts = 0;
            do {
                newPassenger = {
                    x: Math.floor(Math.random() * tileCountX),
                    y: Math.floor(Math.random() * tileCountY),
                    emoji: passengerEmojis[Math.floor(Math.random() * passengerEmojis.length)]
                };
                attempts++;
            } while ((isOnBus(newPassenger.x, newPassenger.y) ||
                     isOnPassenger(newPassenger.x, newPassenger.y) ||
                     isOnBusStop(newPassenger.x, newPassenger.y) ||
                     isOnConstruction(newPassenger.x, newPassenger.y) ||
                     isOnFutureConstruction(newPassenger.x, newPassenger.y) ||
                     isOnBumper(newPassenger.x, newPassenger.y) ||
                     isOnLetter(newPassenger.x, newPassenger.y) ||
                     isOnLandmark(newPassenger.x, newPassenger.y)) && attempts < 100);

            if (attempts < 100) {
                passengers.push(newPassenger);
            }
        }

        function isOnBusStop(x, y) {
            return busStops.some(stop => stop.x === x && stop.y === y);
        }

        function isOnConstruction(x, y) {
            if (!constructionZone || constructionFading) return false;
            return x >= constructionZone.x && x < constructionZone.x + 4 &&
                   y >= constructionZone.y && y < constructionZone.y + 3;
        }

        function isOnFutureConstruction(x, y) {
            if (!futureConstructionZone) return false;
            return x >= futureConstructionZone.x && x < futureConstructionZone.x + 4 &&
                   y >= futureConstructionZone.y && y < futureConstructionZone.y + 3;
        }

        function spawnConstructionZone() {
            if (constructionZone || constructionFading) return;

            // Use pre-determined future location if available
            if (futureConstructionZone) {
                constructionZone = futureConstructionZone;
                futureConstructionZone = null;
                constructionPassengerCount = 0;
                constructionCompleted = false;
                return;
            }

            let attempts = 0;
            let zone;
            do {
                zone = {
                    x: Math.floor(Math.random() * (tileCountX - 4)),
                    y: Math.floor(Math.random() * (tileCountY - 3))
                };
                attempts++;
            } while (isConstructionOverlapping(zone) && attempts < 100);

            if (attempts < 100) {
                constructionZone = zone;
                constructionPassengerCount = 0;
                constructionCompleted = false;
            }
        }

        function pickFutureConstructionLocation() {
            if (futureConstructionZone) return; // Already picked

            let attempts = 0;
            let zone;
            do {
                zone = {
                    x: Math.floor(Math.random() * (tileCountX - 4)),
                    y: Math.floor(Math.random() * (tileCountY - 3))
                };
                attempts++;
            } while (isConstructionOverlapping(zone) && attempts < 100);

            if (attempts < 100) {
                futureConstructionZone = zone;
            }
        }

        function isConstructionOverlapping(zone) {
            // Check all 4x3 cells of the zone
            for (let dx = 0; dx < 4; dx++) {
                for (let dy = 0; dy < 3; dy++) {
                    const x = zone.x + dx;
                    const y = zone.y + dy;
                    if (isOnBus(x, y) || isOnPassenger(x, y) || isOnBusStop(x, y) ||
                        isOnBumper(x, y) || isOnLetter(x, y) || isOnLandmark(x, y)) {
                        return true;
                    }
                }
            }
            return false;
        }

        function startConstructionFade() {
            constructionShowCheckmark = true;
            constructionFading = true;

            // Show checkmark for 0.5 seconds
            setTimeout(() => {
                constructionShowCheckmark = false;
                // Start fade out
                const fadeInterval = setInterval(() => {
                    constructionFadeOpacity -= 0.1;
                    if (constructionFadeOpacity <= 0) {
                        clearInterval(fadeInterval);
                        constructionZone = null;
                        constructionFading = false;
                        constructionFadeOpacity = 1;
                        constructionCompleted = true;
                        passengersUntilConstruction = 7; // Reset countdown for next construction
                    }
                }, 50);
            }, 500);
        }
        
        function spawnBusStop() {
            // Calculate max stops: base 5 + 1 additional for every 250 points
            const maxStops = 5 + Math.floor(score / 250);
            // Only spawn if 7 passengers picked up, bus is long enough, and under max stops
            if (passengersPickedUp >= 7 && bus.length > 3 && busStops.length < maxStops) {
                let newStop;
                let attempts = 0;
                do {
                    newStop = {
                        x: Math.floor(Math.random() * tileCountX),
                        y: Math.floor(Math.random() * tileCountY)
                    };
                    attempts++;
                } while ((isOnBus(newStop.x, newStop.y) ||
                         isOnPassenger(newStop.x, newStop.y) ||
                         isOnConstruction(newStop.x, newStop.y) ||
                         isOnFutureConstruction(newStop.x, newStop.y) ||
                         isOnBumper(newStop.x, newStop.y) ||
                         isOnLetter(newStop.x, newStop.y) ||
                         isOnLandmark(newStop.x, newStop.y)) && attempts < 100);

                if (attempts < 100) {
                    busStops.push(newStop);
                    passengersPickedUp = 0; // Reset counter after spawning stop
                }
            }
        }
        
        function isOnBus(x, y) {
            return bus.some(segment => segment.x === x && segment.y === y);
        }
        
        function isOnPassenger(x, y) {
            return passengers.some(p => p.x === x && p.y === y);
        }
        
        function update() {
            if (!gameRunning) return;

            direction = { ...nextDirection };

            // Move bus
            let head = { x: bus[0].x + direction.x, y: bus[0].y + direction.y };

            // Check for neighborhood transition (going through corridors at edges)
            let transitioned = false;
            if (head.x < 0) {
                // Going left - transition to west neighborhood
                currentNeighborhoodX = (currentNeighborhoodX - 1 + 3) % 3;
                head.x = tileCountX - 1;
                transitioned = true;
            } else if (head.x >= tileCountX) {
                // Going right - transition to east neighborhood
                currentNeighborhoodX = (currentNeighborhoodX + 1) % 3;
                head.x = 0;
                transitioned = true;
            } else if (head.y < 0) {
                // Going up - transition to north neighborhood
                currentNeighborhoodY = (currentNeighborhoodY - 1 + 3) % 3;
                head.y = tileCountY - 1;
                transitioned = true;
            } else if (head.y >= tileCountY) {
                // Going down - transition to south neighborhood
                currentNeighborhoodY = (currentNeighborhoodY + 1) % 3;
                head.y = 0;
                transitioned = true;
            }

            if (transitioned) {
                // Update display and clear current neighborhood entities
                updateNeighborhoodDisplay();
                passengers = [];
                busStops = [];
                constructionZone = null;
                futureConstructionZone = null;
                constructionFading = false;
                constructionFadeOpacity = 1;
                constructionShowCheckmark = false;
                constructionCompleted = true;
                passengersUntilConstruction = 7;

                // Spawn passengers in new neighborhood
                const initialPassengers = 3 + Math.floor(Math.random() * 2);
                for (let i = 0; i < initialPassengers; i++) {
                    spawnPassenger();
                }
            }

            // Check collision with bumpers (instant death)
            if (isOnBumper(head.x, head.y)) {
                endGame();
                return;
            }

            // Check collision with self
            if (isOnBus(head.x, head.y)) {
                endGame();
                return;
            }

            // Check collision with construction zone
            if (isOnConstruction(head.x, head.y)) {
                endGame();
                return;
            }

            bus.unshift(head);

            // Check letter collection
            const state = getCurrentNeighborhoodState();
            state.letterPositions.forEach((letter, index) => {
                if (!state.collectedLetters[index] && head.x === letter.x && head.y === letter.y) {
                    state.collectedLetters[index] = true;
                    if (letter.isPassenger) {
                        // Passenger letter - bus grows, +10 points
                        score += 10;
                        playCoinSound();
                    } else {
                        // Stop letter - drop off passengers if possible
                        if (bus.length > 3) {
                            const dropOff = Math.min(3, bus.length - 3);
                            for (let i = 0; i < dropOff; i++) {
                                bus.pop();
                            }
                            score += dropOff * 15;
                            playDingDongSound();
                        } else {
                            score += 15;
                            playDingDongSound();
                        }
                    }

                    // Check if all letters collected - reveal etched name
                    if (state.collectedLetters.every(c => c)) {
                        state.etchedName = true;
                    }
                }
            });

            // Check landmark collection (2x2 area)
            if (!state.landmarkCollected) {
                const landmarkPos = getLandmarkPosition();
                if (head.x >= landmarkPos.x && head.x < landmarkPos.x + 2 &&
                    head.y >= landmarkPos.y && head.y < landmarkPos.y + 2) {
                    state.landmarkCollected = true;
                    score += 200;
                    playCoinSound();
                }
            }

            // Check passenger pickup
            let pickedUp = false;
            passengers = passengers.filter(passenger => {
                if (passenger.x === head.x && passenger.y === head.y) {
                    const oldScore = score;
                    score += 10;
                    pickedUp = true;
                    passengersPickedUp++;

                    // Track neighborhood-specific passenger count for landmark respawn
                    const neighborhoodState = getCurrentNeighborhoodState();
                    neighborhoodState.passengersPickedUp++;

                    // Check if landmark should respawn (10 passengers in this neighborhood after collection)
                    if (neighborhoodState.landmarkCollected && neighborhoodState.passengersPickedUp >= 10) {
                        neighborhoodState.landmarkCollected = false;
                        neighborhoodState.passengersPickedUp = 0;
                    }

                    // Track passengers for construction zone removal
                    if (constructionZone && !constructionFading) {
                        constructionPassengerCount++;
                        if (constructionPassengerCount >= 4) {
                            startConstructionFade();
                        }
                    }

                    // Speed up every 100 points
                    if (Math.floor(score / 100) > Math.floor(oldScore / 100)) {
                        gameSpeed = Math.max(50, gameSpeed - 15); // Don't go faster than 50ms
                        clearInterval(gameLoop);
                        gameLoop = setInterval(update, gameSpeed);
                    }

                    return false;
                }
                return true;
            });

            if (pickedUp) {
                playCoinSound();

                // Maintain 3-4 passengers on screen
                while (passengers.length < 3) {
                    spawnPassenger();
                }

                // Construction zone spawning logic - only after previous completed AND 7 passengers
                if (constructionCompleted && !constructionZone && !constructionFading) {
                    passengersUntilConstruction--;

                    // At 3 passengers remaining, pick the future location
                    if (passengersUntilConstruction === 3 && !futureConstructionZone) {
                        pickFutureConstructionLocation();
                    }

                    // When countdown reaches 0, spawn the construction zone
                    if (passengersUntilConstruction <= 0) {
                        spawnConstructionZone();
                    }
                }

                spawnBusStop();
            } else {
                bus.pop(); // Remove tail if no passenger picked up
            }

            // Check bus stop
            busStops = busStops.filter(stop => {
                if (stop.x === head.x && stop.y === head.y) {
                    // Drop off passengers - shrink bus
                    if (bus.length > 3) {
                        const dropOff = Math.min(3, bus.length - 3);
                        for (let i = 0; i < dropOff; i++) {
                            bus.pop();
                        }
                        score += dropOff * 15;
                        playDingDongSound();
                    }
                    return false;
                }
                return true;
            });

            updateScore();
            draw();
        }
        
        function draw() {
            const hood = getCurrentNeighborhood();
            const hoodState = getCurrentNeighborhoodState();

            // Clear canvas with neighborhood background color
            ctx.fillStyle = hood.color;
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);

            // Draw grid (portrait canvas)
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            for (let i = 0; i <= tileCountX; i++) {
                ctx.beginPath();
                ctx.moveTo(i * gridSize, 0);
                ctx.lineTo(i * gridSize, canvasHeight);
                ctx.stroke();
            }
            for (let i = 0; i <= tileCountY; i++) {
                ctx.beginPath();
                ctx.moveTo(0, i * gridSize);
                ctx.lineTo(canvasWidth, i * gridSize);
                ctx.stroke();
            }

            // Draw L-shaped corner bumpers (with lighter shade of neighborhood color)
            const bumperColor = lightenColor(hood.color, 30);
            ctx.fillStyle = bumperColor;
            getAllBumperPositions().forEach(pos => {
                ctx.fillRect(pos.x * gridSize, pos.y * gridSize, gridSize, gridSize);
            });

            // Draw etched neighborhood name (if all letters collected)
            if (hoodState.etchedName) {
                ctx.font = 'bold 20px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';

                const words = hood.name.split(' ');
                const centerY = Math.floor(tileCountY / 2);
                let currentY = centerY - Math.floor(words.length / 2);

                words.forEach(word => {
                    const wordCenterX = Math.floor(tileCountX / 2) * gridSize + gridSize / 2;
                    const wordCenterY = currentY * gridSize + gridSize / 2;
                    ctx.fillText(word, wordCenterX, wordCenterY);
                    currentY += 2;
                });
            }

            // Draw uncollected letter emojis
            ctx.font = '24px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            hoodState.letterPositions.forEach((letter, index) => {
                if (!hoodState.collectedLetters[index]) {
                    const emoji = letter.isPassenger ? 'üßç' : 'üöè';
                    const px = letter.x * gridSize + gridSize / 2;
                    const py = letter.y * gridSize + gridSize / 2;
                    ctx.fillText(emoji, px, py);
                }
            });

            // Draw landmark (2x2 emoji) if not collected
            if (!hoodState.landmarkCollected) {
                const landmarkPos = getLandmarkPosition();
                ctx.font = '48px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const lx = landmarkPos.x * gridSize + gridSize;
                const ly = landmarkPos.y * gridSize + gridSize;
                ctx.fillText(hood.landmark, lx, ly);
            }

            // Draw construction countdown warning (if future zone is picked and countdown is 3 or less)
            if (futureConstructionZone && passengersUntilConstruction <= 3 && passengersUntilConstruction > 0) {
                const zoneX = futureConstructionZone.x * gridSize;
                const zoneY = futureConstructionZone.y * gridSize;
                const zoneWidth = 4 * gridSize;
                const zoneHeight = 3 * gridSize;

                // Choose color based on countdown
                let bgColor;
                if (passengersUntilConstruction === 3) {
                    bgColor = 'rgba(255, 200, 0, 0.6)'; // Yellow/caution
                } else if (passengersUntilConstruction === 2) {
                    bgColor = 'rgba(255, 140, 0, 0.7)'; // Orange
                } else {
                    bgColor = 'rgba(255, 60, 60, 0.8)'; // Red
                }

                // Draw full 4x3 highlighted background
                ctx.fillStyle = bgColor;
                ctx.fillRect(zoneX, zoneY, zoneWidth, zoneHeight);

                // Draw border around the zone
                ctx.strokeStyle = passengersUntilConstruction === 1 ? '#ff3333' :
                                  passengersUntilConstruction === 2 ? '#ff8c00' : '#ffcc00';
                ctx.lineWidth = 3;
                ctx.strokeRect(zoneX + 1.5, zoneY + 1.5, zoneWidth - 3, zoneHeight - 3);

                const centerX = zoneX + zoneWidth / 2;
                const centerY = zoneY + zoneHeight / 2;

                // Draw "Closure in" text above the number
                ctx.font = 'bold 16px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = '#fff';
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 3;
                ctx.strokeText('Closure in', centerX, centerY - 20);
                ctx.fillText('Closure in', centerX, centerY - 20);

                // Draw countdown number in center
                ctx.font = 'bold 44px sans-serif';
                ctx.lineWidth = 4;
                ctx.strokeText(passengersUntilConstruction.toString(), centerX, centerY + 12);
                ctx.fillText(passengersUntilConstruction.toString(), centerX, centerY + 12);
            }

            // Draw construction zone (if active)
            if (constructionZone) {
                // 4x3 emoji layout:
                // Top row: üöß üöß üöß üöß
                // Middle row: ‚ö†Ô∏è üë∑ üë∑ ‚ö†Ô∏è
                // Bottom row: üöß üöß üöß üöß
                const constructionLayout = [
                    ['üöß', 'üöß', 'üöß', 'üöß'],
                    ['‚ö†Ô∏è', 'üë∑', 'üë∑', '‚ö†Ô∏è'],
                    ['üöß', 'üöß', 'üöß', 'üöß']
                ];
                ctx.globalAlpha = constructionFadeOpacity;

                if (constructionShowCheckmark) {
                    // Show green checkmark
                    ctx.font = '72px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    const centerX = (constructionZone.x + 2) * gridSize;
                    const centerY = (constructionZone.y + 1.5) * gridSize;
                    ctx.fillText('‚úÖ', centerX, centerY);
                } else {
                    // Draw 4x3 construction zone with specific emoji layout
                    ctx.font = '24px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';

                    for (let dy = 0; dy < 3; dy++) {
                        for (let dx = 0; dx < 4; dx++) {
                            const x = (constructionZone.x + dx) * gridSize + gridSize / 2;
                            const y = (constructionZone.y + dy) * gridSize + gridSize / 2;
                            ctx.fillText(constructionLayout[dy][dx], x, y);
                        }
                    }
                }
                ctx.globalAlpha = 1;
            }

            // Draw bus (pixel art style - kept as-is)
            bus.forEach((segment, index) => {
                if (index === 0) {
                    // Bus head (front) with windshield and bumper
                    ctx.fillStyle = '#E16710';
                    ctx.fillRect(
                        segment.x * gridSize + 1,
                        segment.y * gridSize + 1,
                        gridSize - 2,
                        gridSize - 2
                    );

                    // Blue windshield (top third)
                    ctx.fillStyle = '#33CCFF';
                    ctx.fillRect(
                        segment.x * gridSize + 2,
                        segment.y * gridSize + 2,
                        gridSize - 4,
                        (gridSize - 4) / 3
                    );

                    // Gray bumper (bottom quarter)
                    ctx.fillStyle = '#ADB8BF';
                    ctx.fillRect(
                        segment.x * gridSize + 2,
                        segment.y * gridSize + gridSize - 2 - (gridSize - 4) / 4,
                        gridSize - 4,
                        (gridSize - 4) / 4
                    );
                } else if (index === bus.length - 1) {
                    // Bus back with gray rectangle on bottom third
                    ctx.fillStyle = '#E16710';
                    ctx.fillRect(
                        segment.x * gridSize + 1,
                        segment.y * gridSize + 1,
                        gridSize - 2,
                        gridSize - 2
                    );

                    // Gray rectangle on bottom third
                    ctx.fillStyle = '#ADB8BF';
                    ctx.fillRect(
                        segment.x * gridSize + 2,
                        segment.y * gridSize + gridSize - 2 - (gridSize - 4) / 3,
                        gridSize - 4,
                        (gridSize - 4) / 3
                    );
                } else {
                    // Middle bus segments
                    ctx.fillStyle = '#E16710';
                    ctx.fillRect(
                        segment.x * gridSize + 1,
                        segment.y * gridSize + 1,
                        gridSize - 2,
                        gridSize - 2
                    );

                    // Add blue windows to make it look like a bus (adjusted for 25px grid)
                    ctx.fillStyle = '#33CCFF';
                    ctx.fillRect(
                        segment.x * gridSize + 5,
                        segment.y * gridSize + 5,
                        5,
                        5
                    );
                    ctx.fillRect(
                        segment.x * gridSize + gridSize - 10,
                        segment.y * gridSize + 5,
                        5,
                        5
                    );
                }
            });

            // Draw passengers using emojis
            ctx.font = '24px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            passengers.forEach(passenger => {
                const px = passenger.x * gridSize + gridSize / 2;
                const py = passenger.y * gridSize + gridSize / 2;
                ctx.fillText(passenger.emoji, px, py);
            });

            // Draw bus stops using üöè emoji
            ctx.font = '26px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            busStops.forEach(stop => {
                const sx = stop.x * gridSize + gridSize / 2;
                const sy = stop.y * gridSize + gridSize / 2;
                ctx.fillText('üöè', sx, sy);
            });
        }
        
        function updateScore() {
            document.getElementById('score').textContent = `SCORE: ${score}`;
        }
        
        function endGame() {
            gameRunning = false;
            clearInterval(gameLoop);
            
            // Save high scores
            let highScores = JSON.parse(localStorage.getItem('metroHighScores') || '[]');
            highScores.push(score);
            highScores.sort((a, b) => b - a);
            highScores = highScores.slice(0, 3);
            localStorage.setItem('metroHighScores', JSON.stringify(highScores));
            
            // Display game over
            document.getElementById('finalScore').textContent = `YOUR SCORE: ${score}`;
            
            let highScoresHTML = '<h3>TOP SCORES</h3>';
            highScores.forEach((s, i) => {
                highScoresHTML += `<p>${i + 1}. ${s}</p>`;
            });
            document.getElementById('highScores').innerHTML = highScoresHTML;
            
            document.getElementById('gameOver').style.display = 'block';
        }
        
        document.getElementById('restartBtn').addEventListener('click', initGame);

        // Start screen handler
        document.getElementById('tapToStart').addEventListener('click', function() {
            // Initialize audio context for iOS
            initAudio();
            // Hide start screen
            document.getElementById('startScreen').style.display = 'none';
            // Start the game
            initGame();
        });

        // Initialize neighborhood states and draw initial state without starting game loop
        initAllNeighborhoodStates();
        updateNeighborhoodDisplay();
        draw();
    </script>
</body>
</html>
