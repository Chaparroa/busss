<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Busss - The Game</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
            color: #fff;
            touch-action: none;
        }
        
        #gameContainer {
            text-align: center;
            max-width: 100vw;
        }
        
        #header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            max-width: 375px;
            margin-left: auto;
            margin-right: auto;
            padding: 0 10px;
        }
        
        #title {
            font-size: 36px;
            font-weight: bold;
            color: #E16710;
            text-align: left;
        }
        
        #score {
            font-size: 20px;
            color: #E16710;
            text-align: right;
        }
        
        #canvas {
            border: none;
            background: #1a1a1a;
            display: block;
            margin: 0 auto;
            max-width: 100vw;
            max-height: 85vh;
        }
        
        #gameOver {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #000;
            border: 4px solid #E16710;
            padding: 30px;
            text-align: center;
        }
        
        #gameOver h1 {
            color: #E16710;
            font-size: 36px;
            margin-bottom: 20px;
        }
        
        #gameOver p {
            font-size: 20px;
            margin: 10px 0;
        }
        
        #restartBtn {
            margin-top: 20px;
            padding: 15px 30px;
            font-size: 20px;
            background: #E16710;
            color: #000;
            border: none;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-weight: bold;
        }
        
        #restartBtn:active {
            background: #c75509;
        }
        
        .high-scores {
            margin-top: 20px;
            font-size: 16px;
            color: #ffaa00;
        }
        
        #startScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        #startScreen img {
            max-width: 98%;
            max-height: 58vh;
            border: none;
            border-radius: 0;
        }

        #startInstructions {
            margin-top: 15px;
            text-align: left;
            padding: 12px 18px;
            background: rgba(225, 103, 16, 0.1);
            border: 2px solid #E16710;
            border-radius: 8px;
            max-width: 350px;
        }

        #startInstructions p {
            margin: 6px 0;
            font-size: 15px;
            color: #fff;
        }

        #tapToStart {
            margin-top: 15px;
            padding: 20px 50px;
            font-size: 28px;
            background: #E16710;
            color: #000;
            border: none;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            border-radius: 8px;
            animation: pulse 1.5s ease-in-out infinite;
        }

        #tapToStart:active {
            background: #c75509;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
    </style>
</head>
<body>
    <div id="startScreen">
        <img src="cover-art-busss.png" alt="BUSSS Cover Art">
        <div id="startInstructions">
            <p>üöå Swipe to change direction</p>
            <p>üßç Pick up passengers (+10pts)</p>
            <p>üöè Drop off at stops to shrink (+15pts)</p>
            <p>üöß Avoid construction & üöóüöô traffic!</p>
        </div>
        <button id="tapToStart">TAP TO START</button>
    </div>

    <div id="gameContainer">
        <div id="header">
            <div id="title">BUSSS</div>
            <div id="score">SCORE: 0</div>
        </div>
        <canvas id="canvas"></canvas>
    </div>
    
    <div id="gameOver">
        <h1>GAME OVER</h1>
        <p id="finalScore"></p>
        <div class="high-scores" id="highScores"></div>
        <button id="restartBtn">PLAY AGAIN</button>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Set canvas size - portrait orientation for mobile
        // Hi-DPI support for crisp rendering on retina displays
        const dpr = window.devicePixelRatio || 1;
        const gridSize = 25;
        const canvasWidth = 375;
        const canvasHeight = 625;

        // Set actual canvas dimensions scaled by device pixel ratio
        canvas.width = canvasWidth * dpr;
        canvas.height = canvasHeight * dpr;

        // Set CSS display size (visual size on screen)
        canvas.style.width = canvasWidth + 'px';
        canvas.style.height = canvasHeight + 'px';

        // Scale context to match device pixel ratio for crisp rendering
        ctx.scale(dpr, dpr);

        const tileCountX = Math.floor(canvasWidth / gridSize);
        const tileCountY = Math.floor(canvasHeight / gridSize);

        // Game state
        let bus = [];
        let direction = { x: 1, y: 0 };
        let nextDirection = { x: 1, y: 0 };
        let passengers = [];
        let busStops = [];
        let score = 0;
        let gameRunning = false;
        let gameLoop;
        let passengersPickedUp = 0;
        let globalPassengersPickedUp = 0;
        let gameSpeed = 150;

        // Neighborhood system - 3x3 grid of LA neighborhoods
        const NEIGHBORHOODS = {
            // Row 0 (top)
            '0,0': { name: 'HOLLYWOOD', color: '#4a1942', landmark: 'üé¨' },
            '1,0': { name: 'PASADENA', color: '#1a4a3a', landmark: 'üèõÔ∏è' },
            '2,0': { name: 'VAN NUYS', color: '#3a3a1a', landmark: 'üõ©Ô∏è' },
            // Row 1 (middle)
            '0,1': { name: 'SANTA MONICA', color: '#1a3a4a', landmark: 'üé°' },
            '1,1': { name: 'DOWNTOWN', color: '#2a2a3a', landmark: 'üèôÔ∏è' },
            '2,1': { name: 'EAST LA', color: '#4a2a1a', landmark: 'üåÆ' },
            // Row 2 (bottom)
            '0,2': { name: 'COMPTON', color: '#3a1a3a', landmark: 'üèÄ' },
            '1,2': { name: 'SOUTH CENTRAL', color: '#2a3a2a', landmark: 'üéµ' },
            '2,2': { name: 'LONG BEACH', color: '#1a3a3a', landmark: '‚õ±Ô∏è' }
        };

        // Current neighborhood position (start at Downtown which is center: 1,1)
        let currentNeighborhoodX = 1;
        let currentNeighborhoodY = 1;

        // State for each neighborhood - tracks visited, landmark, construction, traffic
        let neighborhoodStates = {};

        // Traffic state - cars moving across neighborhoods
        let globalCarSpawnCount = 0; // Alternates red/blue

        // Get current neighborhood data
        function getCurrentNeighborhood() {
            return NEIGHBORHOODS[`${currentNeighborhoodX},${currentNeighborhoodY}`];
        }

        // Get current neighborhood state
        function getCurrentNeighborhoodState() {
            const key = `${currentNeighborhoodX},${currentNeighborhoodY}`;
            if (!neighborhoodStates[key]) {
                initNeighborhoodState(key);
            }
            return neighborhoodStates[key];
        }

        // Get neighborhood state by key (for cross-neighborhood updates)
        function getNeighborhoodStateByKey(key) {
            if (!neighborhoodStates[key]) {
                initNeighborhoodState(key);
            }
            return neighborhoodStates[key];
        }

        // Initialize state for a neighborhood
        function initNeighborhoodState(key) {
            neighborhoodStates[key] = {
                visited: false,
                landmarkCollected: false,
                passengersPickedUp: 0,
                // Per-neighborhood passengers and bus stops (persist across transitions)
                savedPassengers: [],
                savedBusStops: [],
                initialized: false,
                // Bus stop spawn tracking (per neighborhood)
                passengersPickedUpForStops: 0,
                // Construction state per neighborhood
                constructionZone: null,
                constructionPassengerCount: 0,
                constructionFading: false,
                constructionFadeOpacity: 1,
                constructionShowCheckmark: false,
                constructionCompleted: true,
                futureConstructionZone: null,
                passengersUntilConstruction: 8,
                // Traffic state per neighborhood
                car: null, // { x, y, direction, type: 'red'|'blue', speed }
                totalPassengersPickedUp: 0 // For car spawn tracking
            };
        }

        // Get landmark position for current neighborhood (2x2, centered on screen)
        function getLandmarkPosition() {
            // Place landmark centered horizontally, in upper portion of screen
            // Canvas is 15 tiles wide (0-14), center is around tile 5-6 for a 2x2 landmark
            // Leave room for name to the right
            return { x: 4, y: 3 };
        }

        // Check if position is on landmark (2x2 area)
        function isOnLandmark(x, y) {
            const state = getCurrentNeighborhoodState();
            if (state.landmarkCollected) return false;

            const pos = getLandmarkPosition();
            return x >= pos.x && x < pos.x + 2 && y >= pos.y && y < pos.y + 2;
        }

        // Check if position is on car
        function isOnCar(x, y) {
            const state = getCurrentNeighborhoodState();
            if (!state.car) return false;
            return state.car.x === x && state.car.y === y;
        }

        // Get neighbor name in a direction
        function getNeighborName(dx, dy) {
            const nx = (currentNeighborhoodX + dx + 3) % 3;
            const ny = (currentNeighborhoodY + dy + 3) % 3;
            return NEIGHBORHOODS[`${nx},${ny}`].name;
        }

        // Initialize all neighborhood states
        function initAllNeighborhoodStates() {
            neighborhoodStates = {};
            globalCarSpawnCount = 0;
            Object.keys(NEIGHBORHOODS).forEach(key => {
                initNeighborhoodState(key);
            });
        }

        // Passenger emojis - full figure standing people
        const passengerEmojis = ['üßç', 'üßç‚Äç‚ôÇÔ∏è', 'üßç‚Äç‚ôÄÔ∏è'];
        
        // Audio context for sound effects
        let audioContext = null;
        let coinSoundPlaying = false;
        let dingDongPlaying = false;
        let audioInitialized = false;
        let twinkleSoundPlaying = false;
        let honkSoundPlaying = false;

        function initAudio() {
            // Create AudioContext if it doesn't exist
            if (!audioContext) {
                try {
                    // Use standard AudioContext or webkit prefix for older Safari
                    const AudioCtx = window.AudioContext || window.webkitAudioContext;
                    if (AudioCtx) {
                        audioContext = new AudioCtx();
                        console.log('AudioContext created, state:', audioContext.state);
                    }
                } catch (e) {
                    console.warn('Web Audio API not supported:', e);
                    return;
                }
            }

            if (!audioContext) return;

            // Always try to resume if suspended (required for both mobile AND desktop)
            // Desktop browsers (Chrome, Safari, Firefox) all require user gesture to start audio
            if (audioContext.state === 'suspended') {
                audioContext.resume().then(() => {
                    audioInitialized = true;
                    console.log('AudioContext resumed successfully');
                    // Play a silent sound to fully unlock audio on some browsers
                    unlockAudio();
                }).catch(e => console.warn('Audio resume failed:', e));
            } else if (audioContext.state === 'running') {
                audioInitialized = true;
            }
        }

        // Play a silent sound to unlock audio context on user gesture
        function unlockAudio() {
            if (!audioContext) return;
            try {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                gainNode.gain.value = 0; // Silent
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                oscillator.start(0);
                oscillator.stop(audioContext.currentTime + 0.001);
            } catch (e) {
                // Ignore errors
            }
        }

        function playCoinSound() {
            // Ensure audio context is initialized
            if (!audioContext) {
                initAudio();
                return;
            }
            if (coinSoundPlaying) return;

            // Resume audio context if suspended (browser autoplay policy)
            if (audioContext.state === 'suspended') {
                audioContext.resume().then(() => {
                    doPlayCoinSound();
                });
                return;
            }

            doPlayCoinSound();
        }

        function doPlayCoinSound() {
            if (!audioContext || coinSoundPlaying) return;
            coinSoundPlaying = true;

            try {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                // Create a pleasant coin chime effect
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(987.77, audioContext.currentTime); // B5
                oscillator.frequency.setValueAtTime(1318.51, audioContext.currentTime + 0.08); // E6

                // Quick fade in and out for a clean sound
                gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(0.3, audioContext.currentTime + 0.02);
                gainNode.gain.linearRampToValueAtTime(0.2, audioContext.currentTime + 0.08);
                gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.15);

                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.15);
            } catch (e) {
                console.warn('Coin sound error:', e);
            }

            // Allow next sound after this one finishes
            setTimeout(() => {
                coinSoundPlaying = false;
            }, 100);
        }

        function playDingDongSound() {
            // Ensure audio context is initialized and resumed
            if (!audioContext) {
                initAudio();
                return; // Skip this sound, next one will work
            }
            if (dingDongPlaying) return;

            // Resume audio context if suspended (browser autoplay policy)
            if (audioContext.state === 'suspended') {
                audioContext.resume().then(() => {
                    doPlayDingDongSound();
                });
                return;
            }

            doPlayDingDongSound();
        }

        function doPlayDingDongSound() {
            if (!audioContext || dingDongPlaying) return;
            dingDongPlaying = true;

            try {
                // First tone - "ding" (higher pitch)
                const oscillator1 = audioContext.createOscillator();
                const gainNode1 = audioContext.createGain();
                oscillator1.connect(gainNode1);
                gainNode1.connect(audioContext.destination);
                oscillator1.type = 'sine';
                oscillator1.frequency.setValueAtTime(830.61, audioContext.currentTime); // G#5
                gainNode1.gain.setValueAtTime(0, audioContext.currentTime);
                gainNode1.gain.linearRampToValueAtTime(0.35, audioContext.currentTime + 0.02);
                gainNode1.gain.linearRampToValueAtTime(0.25, audioContext.currentTime + 0.15);
                gainNode1.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.3);
                oscillator1.start(audioContext.currentTime);
                oscillator1.stop(audioContext.currentTime + 0.3);

                // Second tone - "dong" (lower pitch, starts slightly after)
                const oscillator2 = audioContext.createOscillator();
                const gainNode2 = audioContext.createGain();
                oscillator2.connect(gainNode2);
                gainNode2.connect(audioContext.destination);
                oscillator2.type = 'sine';
                oscillator2.frequency.setValueAtTime(622.25, audioContext.currentTime + 0.15); // D#5
                gainNode2.gain.setValueAtTime(0, audioContext.currentTime + 0.15);
                gainNode2.gain.linearRampToValueAtTime(0.35, audioContext.currentTime + 0.17);
                gainNode2.gain.linearRampToValueAtTime(0.25, audioContext.currentTime + 0.3);
                gainNode2.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.5);
                oscillator2.start(audioContext.currentTime + 0.15);
                oscillator2.stop(audioContext.currentTime + 0.5);
            } catch (e) {
                console.warn('Ding dong sound error:', e);
            }

            // Allow next sound after this one finishes
            setTimeout(() => {
                dingDongPlaying = false;
            }, 400);
        }

        function playTwinkleSound() {
            if (!audioContext) {
                initAudio();
                return;
            }
            if (twinkleSoundPlaying) return;

            if (audioContext.state === 'suspended') {
                audioContext.resume().then(() => {
                    doPlayTwinkleSound();
                });
                return;
            }

            doPlayTwinkleSound();
        }

        function doPlayTwinkleSound() {
            if (!audioContext || twinkleSoundPlaying) return;
            twinkleSoundPlaying = true;

            try {
                // Magical ascending twinkle: C6, E6, G6, C7
                const notes = [1047, 1319, 1568, 2093];
                notes.forEach((freq, i) => {
                    const osc = audioContext.createOscillator();
                    const gain = audioContext.createGain();
                    osc.connect(gain);
                    gain.connect(audioContext.destination);
                    osc.type = 'sine';
                    const startTime = audioContext.currentTime + i * 0.08;
                    osc.frequency.setValueAtTime(freq, startTime);
                    gain.gain.setValueAtTime(0, startTime);
                    gain.gain.linearRampToValueAtTime(0.25, startTime + 0.02);
                    gain.gain.linearRampToValueAtTime(0, startTime + 0.15);
                    osc.start(startTime);
                    osc.stop(startTime + 0.15);
                });
            } catch (e) {
                console.warn('Twinkle sound error:', e);
            }

            setTimeout(() => {
                twinkleSoundPlaying = false;
            }, 400);
        }

        function playHonkSound() {
            if (!audioContext) {
                initAudio();
                return;
            }
            if (honkSoundPlaying) return;

            if (audioContext.state === 'suspended') {
                audioContext.resume().then(() => {
                    doPlayHonkSound();
                });
                return;
            }

            doPlayHonkSound();
        }

        function doPlayHonkSound() {
            if (!audioContext || honkSoundPlaying) return;
            honkSoundPlaying = true;

            try {
                // Car horn: two dissonant square wave tones
                const osc1 = audioContext.createOscillator();
                const osc2 = audioContext.createOscillator();
                const gain = audioContext.createGain();
                osc1.connect(gain);
                osc2.connect(gain);
                gain.connect(audioContext.destination);

                osc1.type = 'square';
                osc2.type = 'square';
                osc1.frequency.setValueAtTime(440, audioContext.currentTime); // A4
                osc2.frequency.setValueAtTime(370, audioContext.currentTime); // F#4

                gain.gain.setValueAtTime(0, audioContext.currentTime);
                gain.gain.linearRampToValueAtTime(0.15, audioContext.currentTime + 0.02);
                gain.gain.setValueAtTime(0.15, audioContext.currentTime + 0.15);
                gain.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.3);

                osc1.start(audioContext.currentTime);
                osc1.stop(audioContext.currentTime + 0.3);
                osc2.start(audioContext.currentTime);
                osc2.stop(audioContext.currentTime + 0.3);
            } catch (e) {
                console.warn('Honk sound error:', e);
            }

            setTimeout(() => {
                honkSoundPlaying = false;
            }, 300);
        }

        // Touch controls
        let touchStartX = 0;
        let touchStartY = 0;
        
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            initAudio();
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
        }, { passive: false });
        
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
        }, { passive: false });
        
        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            if (!gameRunning) return;
            
            const touchEndX = e.changedTouches[0].clientX;
            const touchEndY = e.changedTouches[0].clientY;
            
            const deltaX = touchEndX - touchStartX;
            const deltaY = touchEndY - touchStartY;
            
            // Determine swipe direction
            if (Math.abs(deltaX) > Math.abs(deltaY)) {
                // Horizontal swipe
                if (deltaX > 30 && direction.x === 0) {
                    nextDirection = { x: 1, y: 0 };
                } else if (deltaX < -30 && direction.x === 0) {
                    nextDirection = { x: -1, y: 0 };
                }
            } else {
                // Vertical swipe
                if (deltaY > 30 && direction.y === 0) {
                    nextDirection = { x: 0, y: 1 };
                } else if (deltaY < -30 && direction.y === 0) {
                    nextDirection = { x: 0, y: -1 };
                }
            }
        }, { passive: false });
        
        // Keyboard controls for desktop testing
        document.addEventListener('keydown', (e) => {
            initAudio();
            if (!gameRunning) return;

            switch(e.key) {
                case 'ArrowUp':
                    if (direction.y === 0) nextDirection = { x: 0, y: -1 };
                    break;
                case 'ArrowDown':
                    if (direction.y === 0) nextDirection = { x: 0, y: 1 };
                    break;
                case 'ArrowLeft':
                    if (direction.x === 0) nextDirection = { x: -1, y: 0 };
                    break;
                case 'ArrowRight':
                    if (direction.x === 0) nextDirection = { x: 1, y: 0 };
                    break;
            }
        });

        // Mouse controls for desktop - initialize audio and handle clicks
        canvas.addEventListener('mousedown', (e) => {
            initAudio();
        });

        canvas.addEventListener('click', (e) => {
            initAudio();
        });

        // Initialize audio on any document interaction (for desktop browsers)
        // Don't use { once: true } - need to keep trying until audio is unlocked
        document.addEventListener('click', () => {
            if (!audioInitialized) {
                initAudio();
            }
        });

        document.addEventListener('mousedown', () => {
            if (!audioInitialized) {
                initAudio();
            }
        });

        // Additional keydown listener for desktop keyboard users
        document.addEventListener('keydown', () => {
            if (!audioInitialized) {
                initAudio();
            }
        }, { once: true });
        
        function initGame() {
            bus = [
                { x: Math.floor(tileCountX / 2), y: Math.floor(tileCountY / 2) },
                { x: Math.floor(tileCountX / 2) - 1, y: Math.floor(tileCountY / 2) }
            ];
            direction = { x: 1, y: 0 };
            nextDirection = { x: 1, y: 0 };
            score = 0;
            passengers = [];
            busStops = [];
            gameRunning = true;
            passengersPickedUp = 0;
            globalPassengersPickedUp = 0;
            gameSpeed = 188; // 25% slower than original 150ms

            // Reset neighborhood state - start in Downtown (center)
            currentNeighborhoodX = 1;
            currentNeighborhoodY = 1;
            initAllNeighborhoodStates();

            // Mark starting neighborhood as visited and initialized
            const startState = getCurrentNeighborhoodState();
            startState.visited = true;
            startState.initialized = true;

            updateNeighborhoodDisplay();

            // Spawn exactly 3 passengers initially
            for (let i = 0; i < 3; i++) {
                spawnPassenger();
            }

            document.getElementById('gameOver').style.display = 'none';
            updateScore();

            if (gameLoop) clearInterval(gameLoop);
            gameLoop = setInterval(update, gameSpeed);
        }

        function updateNeighborhoodDisplay() {
            // Neighborhood name is now shown etched on the floor, no header update needed
        }

        function spawnPassenger() {
            let newPassenger;
            let attempts = 0;
            do {
                newPassenger = {
                    x: Math.floor(Math.random() * tileCountX),
                    y: Math.floor(Math.random() * tileCountY),
                    emoji: passengerEmojis[Math.floor(Math.random() * passengerEmojis.length)]
                };
                attempts++;
            } while ((isOnBus(newPassenger.x, newPassenger.y) ||
                     isOnPassenger(newPassenger.x, newPassenger.y) ||
                     isOnBusStop(newPassenger.x, newPassenger.y) ||
                     isOnConstruction(newPassenger.x, newPassenger.y) ||
                     isOnFutureConstruction(newPassenger.x, newPassenger.y) ||
                     isOnLandmark(newPassenger.x, newPassenger.y) ||
                     isOnCar(newPassenger.x, newPassenger.y)) && attempts < 100);

            if (attempts < 100) {
                passengers.push(newPassenger);
            }
        }

        function isOnBusStop(x, y) {
            return busStops.some(stop => stop.x === x && stop.y === y);
        }

        function isOnConstruction(x, y) {
            const state = getCurrentNeighborhoodState();
            if (!state.constructionZone || state.constructionFading) return false;
            return x >= state.constructionZone.x && x < state.constructionZone.x + 4 &&
                   y >= state.constructionZone.y && y < state.constructionZone.y + 3;
        }

        function isOnFutureConstruction(x, y) {
            const state = getCurrentNeighborhoodState();
            if (!state.futureConstructionZone) return false;
            return x >= state.futureConstructionZone.x && x < state.futureConstructionZone.x + 4 &&
                   y >= state.futureConstructionZone.y && y < state.futureConstructionZone.y + 3;
        }

        function spawnConstructionZone() {
            const state = getCurrentNeighborhoodState();
            if (state.constructionZone || state.constructionFading) return;

            // Use pre-determined future location if available
            if (state.futureConstructionZone) {
                state.constructionZone = state.futureConstructionZone;
                state.futureConstructionZone = null;
                state.constructionPassengerCount = 0;
                state.constructionCompleted = false;
                return;
            }

            let attempts = 0;
            let zone;
            do {
                zone = {
                    x: Math.floor(Math.random() * (tileCountX - 4)),
                    y: Math.floor(Math.random() * (tileCountY - 3))
                };
                attempts++;
            } while (isConstructionOverlapping(zone) && attempts < 100);

            if (attempts < 100) {
                state.constructionZone = zone;
                state.constructionPassengerCount = 0;
                state.constructionCompleted = false;
            }
        }

        function pickFutureConstructionLocation() {
            const state = getCurrentNeighborhoodState();
            if (state.futureConstructionZone) return; // Already picked

            let attempts = 0;
            let zone;
            do {
                zone = {
                    x: Math.floor(Math.random() * (tileCountX - 4)),
                    y: Math.floor(Math.random() * (tileCountY - 3))
                };
                attempts++;
            } while (isConstructionOverlapping(zone) && attempts < 100);

            if (attempts < 100) {
                state.futureConstructionZone = zone;
            }
        }

        function isConstructionOverlapping(zone) {
            // Check all 4x3 cells of the zone
            for (let dx = 0; dx < 4; dx++) {
                for (let dy = 0; dy < 3; dy++) {
                    const x = zone.x + dx;
                    const y = zone.y + dy;
                    if (isOnBus(x, y) || isOnPassenger(x, y) || isOnBusStop(x, y) ||
                        isOnLandmark(x, y) || isOnCar(x, y)) {
                        return true;
                    }
                }
            }
            return false;
        }

        function startConstructionFade(neighborhoodKey) {
            const state = getNeighborhoodStateByKey(neighborhoodKey);
            state.constructionShowCheckmark = true;
            state.constructionFading = true;

            // Show checkmark for 0.5 seconds
            setTimeout(() => {
                state.constructionShowCheckmark = false;
                // Start fade out
                const fadeInterval = setInterval(() => {
                    state.constructionFadeOpacity -= 0.1;
                    if (state.constructionFadeOpacity <= 0) {
                        clearInterval(fadeInterval);
                        state.constructionZone = null;
                        state.constructionFading = false;
                        state.constructionFadeOpacity = 1;
                        state.constructionCompleted = true;
                        state.passengersUntilConstruction = 8; // Reset countdown for next construction
                    }
                }, 50);
            }, 500);
        }

        // Traffic functions
        function spawnCar() {
            const state = getCurrentNeighborhoodState();
            if (state.car) return; // Already has a car

            globalCarSpawnCount++;
            const isRed = globalCarSpawnCount % 2 === 1;

            // Random edge and direction
            const edges = ['left', 'right', 'top', 'bottom'];
            const edge = edges[Math.floor(Math.random() * edges.length)];

            let car = {
                type: isRed ? 'red' : 'blue',
                speed: isRed ? 200 : 100, // Red slower (200ms), blue faster (100ms)
                lastMove: Date.now()
            };

            // Set starting position and direction based on edge
            switch (edge) {
                case 'left':
                    car.x = 0;
                    car.y = Math.floor(Math.random() * tileCountY);
                    car.dx = 1;
                    car.dy = 0;
                    break;
                case 'right':
                    car.x = tileCountX - 1;
                    car.y = Math.floor(Math.random() * tileCountY);
                    car.dx = -1;
                    car.dy = 0;
                    break;
                case 'top':
                    car.x = Math.floor(Math.random() * tileCountX);
                    car.y = 0;
                    car.dx = 0;
                    car.dy = 1;
                    break;
                case 'bottom':
                    car.x = Math.floor(Math.random() * tileCountX);
                    car.y = tileCountY - 1;
                    car.dx = 0;
                    car.dy = -1;
                    break;
            }

            state.car = car;
            playHonkSound();
        }

        function updateAllCars() {
            const now = Date.now();
            // Update cars in all neighborhoods
            Object.keys(neighborhoodStates).forEach(key => {
                const state = neighborhoodStates[key];
                if (state.car) {
                    // Check if enough time has passed for this car to move
                    if (now - state.car.lastMove >= state.car.speed) {
                        state.car.x += state.car.dx;
                        state.car.y += state.car.dy;
                        state.car.lastMove = now;

                        // Remove car if it's left the grid
                        if (state.car.x < 0 || state.car.x >= tileCountX ||
                            state.car.y < 0 || state.car.y >= tileCountY) {
                            state.car = null;
                        }
                    }
                }
            });
        }
        
        function spawnBusStop() {
            const state = getCurrentNeighborhoodState();
            const maxStops = 5; // Max 5 stops per neighborhood
            // Spawn after 3 passengers picked up in this neighborhood, bus is long enough, under max
            if (state.passengersPickedUpForStops >= 3 && bus.length > 3 && busStops.length < maxStops) {
                let newStop;
                let attempts = 0;
                do {
                    newStop = {
                        x: Math.floor(Math.random() * tileCountX),
                        y: Math.floor(Math.random() * tileCountY)
                    };
                    attempts++;
                } while ((isOnBus(newStop.x, newStop.y) ||
                         isOnPassenger(newStop.x, newStop.y) ||
                         isOnConstruction(newStop.x, newStop.y) ||
                         isOnFutureConstruction(newStop.x, newStop.y) ||
                         isOnLandmark(newStop.x, newStop.y) ||
                         isOnCar(newStop.x, newStop.y)) && attempts < 100);

                if (attempts < 100) {
                    busStops.push(newStop);
                    state.passengersPickedUpForStops = 0; // Reset per-neighborhood counter
                }
            }
        }
        
        function isOnBus(x, y) {
            return bus.some(segment => segment.x === x && segment.y === y);
        }
        
        function isOnPassenger(x, y) {
            return passengers.some(p => p.x === x && p.y === y);
        }
        
        function update() {
            if (!gameRunning) return;

            // Update all cars in all neighborhoods
            updateAllCars();

            direction = { ...nextDirection };

            // Move bus
            let head = { x: bus[0].x + direction.x, y: bus[0].y + direction.y };

            // Check for neighborhood transitions when bus goes off screen edges
            let transitionedNeighborhood = false;
            const prevNeighborhoodX = currentNeighborhoodX;
            const prevNeighborhoodY = currentNeighborhoodY;

            if (head.x < 0) {
                // Transition to left neighborhood
                currentNeighborhoodX = (currentNeighborhoodX - 1 + 3) % 3;
                head.x = tileCountX - 1;
                transitionedNeighborhood = true;
            } else if (head.x >= tileCountX) {
                // Transition to right neighborhood
                currentNeighborhoodX = (currentNeighborhoodX + 1) % 3;
                head.x = 0;
                transitionedNeighborhood = true;
            }

            if (head.y < 0) {
                // Transition to top neighborhood
                currentNeighborhoodY = (currentNeighborhoodY - 1 + 3) % 3;
                head.y = tileCountY - 1;
                transitionedNeighborhood = true;
            } else if (head.y >= tileCountY) {
                // Transition to bottom neighborhood
                currentNeighborhoodY = (currentNeighborhoodY + 1) % 3;
                head.y = 0;
                transitionedNeighborhood = true;
            }

            // If we transitioned to a NEW neighborhood, preserve bus length
            // Recreate bus segments trailing behind the head from the entry edge
            if (transitionedNeighborhood) {
                // Save old neighborhood's passengers and bus stops
                const oldKey = `${prevNeighborhoodX},${prevNeighborhoodY}`;
                const oldState = getNeighborhoodStateByKey(oldKey);
                oldState.savedPassengers = [...passengers];
                oldState.savedBusStops = [...busStops];

                const newNeighborhoodKey = `${currentNeighborhoodX},${currentNeighborhoodY}`;
                const newState = getNeighborhoodStateByKey(newNeighborhoodKey);
                newState.visited = true;

                // CRITICAL: Preserve bus length when transitioning neighborhoods
                // Create segments trailing behind head in opposite direction of travel
                const busLength = bus.length;
                bus = [{ x: head.x, y: head.y }];

                // Add remaining segments trailing behind (off-screen, will follow naturally)
                for (let i = 1; i < busLength; i++) {
                    const prevSegment = bus[bus.length - 1];
                    // Trail in opposite direction of movement (segments enter from edge)
                    const trailX = prevSegment.x - direction.x;
                    const trailY = prevSegment.y - direction.y;
                    bus.push({ x: trailX, y: trailY });
                }

                // Restore or initialize passengers and bus stops for new neighborhood
                if (newState.initialized) {
                    passengers = [...newState.savedPassengers];
                    busStops = [...newState.savedBusStops];
                } else {
                    passengers = [];
                    busStops = [];
                    for (let i = 0; i < 3; i++) {
                        spawnPassenger();
                    }
                    newState.initialized = true;
                }

                // Ensure minimum 3 passengers per neighborhood
                while (passengers.length < 3) {
                    spawnPassenger();
                }

                updateNeighborhoodDisplay();
                draw();
                return; // Skip the rest of update for this frame
            }

            // Check collision with self (only matters within same neighborhood now)
            if (isOnBus(head.x, head.y)) {
                endGame();
                return;
            }

            // Check collision with construction zone
            if (isOnConstruction(head.x, head.y)) {
                endGame();
                return;
            }

            // Check collision with car (instant death)
            if (isOnCar(head.x, head.y)) {
                endGame();
                return;
            }

            bus.unshift(head);

            const state = getCurrentNeighborhoodState();
            const neighborhoodKey = `${currentNeighborhoodX},${currentNeighborhoodY}`;

            // Check landmark collection (2x2 area)
            if (!state.landmarkCollected) {
                const landmarkPos = getLandmarkPosition();
                if (head.x >= landmarkPos.x && head.x < landmarkPos.x + 2 &&
                    head.y >= landmarkPos.y && head.y < landmarkPos.y + 2) {
                    state.landmarkCollected = true;
                    score += 200;
                    playTwinkleSound();
                }
            }

            // Check passenger pickup
            let pickedUp = false;
            passengers = passengers.filter(passenger => {
                if (passenger.x === head.x && passenger.y === head.y) {
                    score += 10;
                    pickedUp = true;
                    passengersPickedUp++;
                    globalPassengersPickedUp++;

                    // Track neighborhood-specific passenger count for landmark respawn and car spawn
                    state.passengersPickedUp++;
                    state.totalPassengersPickedUp++;
                    state.passengersPickedUpForStops++;

                    // Check if landmark should respawn (10 passengers in this neighborhood after collection)
                    if (state.landmarkCollected && state.passengersPickedUp >= 10) {
                        state.landmarkCollected = false;
                        state.passengersPickedUp = 0;
                    }

                    // Check if car should spawn (every 7 passengers in this neighborhood)
                    if (state.totalPassengersPickedUp % 7 === 0 && !state.car) {
                        spawnCar();
                    }

                    // Track passengers for construction zone removal
                    if (state.constructionZone && !state.constructionFading) {
                        state.constructionPassengerCount++;
                        if (state.constructionPassengerCount >= 4) {
                            startConstructionFade(neighborhoodKey);
                        }
                    }

                    // Speed up every 10 passengers picked up (global count)
                    if (globalPassengersPickedUp % 10 === 0) {
                        gameSpeed = Math.max(50, gameSpeed - 15); // Don't go faster than 50ms
                        clearInterval(gameLoop);
                        gameLoop = setInterval(update, gameSpeed);
                    }

                    return false;
                }
                return true;
            });

            if (pickedUp) {
                playCoinSound();

                // Maintain 3-4 passengers on screen
                while (passengers.length < 3) {
                    spawnPassenger();
                }

                // Construction zone spawning logic - per neighborhood
                if (state.constructionCompleted && !state.constructionZone && !state.constructionFading) {
                    state.passengersUntilConstruction--;

                    // At 3 passengers remaining, pick the future location
                    if (state.passengersUntilConstruction === 3 && !state.futureConstructionZone) {
                        pickFutureConstructionLocation();
                    }

                    // When countdown reaches 0, spawn the construction zone
                    if (state.passengersUntilConstruction <= 0) {
                        spawnConstructionZone();
                    }
                }

                spawnBusStop();
            } else {
                bus.pop(); // Remove tail if no passenger picked up
            }

            // Check bus stop
            busStops = busStops.filter(stop => {
                if (stop.x === head.x && stop.y === head.y) {
                    // Drop off passengers - shrink bus
                    if (bus.length > 3) {
                        const dropOff = Math.min(3, bus.length - 3);
                        for (let i = 0; i < dropOff; i++) {
                            bus.pop();
                        }
                        score += dropOff * 15;
                        playDingDongSound();
                    }
                    return false;
                }
                return true;
            });

            updateScore();
            draw();
        }
        
        function draw() {
            const hood = getCurrentNeighborhood();
            const hoodState = getCurrentNeighborhoodState();

            // Clear canvas with neighborhood background color
            ctx.fillStyle = hood.color;
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);

            // Draw grid (portrait canvas)
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            for (let i = 0; i <= tileCountX; i++) {
                ctx.beginPath();
                ctx.moveTo(i * gridSize, 0);
                ctx.lineTo(i * gridSize, canvasHeight);
                ctx.stroke();
            }
            for (let i = 0; i <= tileCountY; i++) {
                ctx.beginPath();
                ctx.moveTo(0, i * gridSize);
                ctx.lineTo(canvasWidth, i * gridSize);
                ctx.stroke();
            }

            // Draw etched neighborhood name (always visible once visited, centered with landmark)
            if (hoodState.visited) {
                ctx.font = 'bold 18px sans-serif';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';

                const landmarkPos = getLandmarkPosition();
                // Position name to the right of the 2x2 landmark, centered vertically
                const nameX = (landmarkPos.x + 2) * gridSize + 10; // Right of landmark with small gap
                const words = hood.name.split(' ');

                // Center the text block vertically with the landmark
                const totalTextHeight = words.length * 22;
                const landmarkCenterY = (landmarkPos.y * gridSize) + gridSize; // Center of 2x2 landmark
                let currentY = landmarkCenterY - (totalTextHeight / 2) + 11; // Start position to center text block

                words.forEach(word => {
                    ctx.fillText(word, nameX, currentY);
                    currentY += 22;
                });
            }

            // Draw etched directional arrows (smaller text, on edges)
            ctx.font = '11px sans-serif';
            ctx.fillStyle = 'rgba(255, 255, 255, 0.25)';
            ctx.textBaseline = 'middle';

            // Left arrow - arrow LEFT of the neighborhood name (‚Üê [Name])
            ctx.save();
            ctx.translate(14, canvasHeight / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.textAlign = 'center';
            ctx.fillText('‚Üê ' + getNeighborName(-1, 0), 0, 0);
            ctx.restore();

            // Right arrow - arrow RIGHT of the neighborhood name ([Name] ‚Üí)
            ctx.save();
            ctx.translate(canvasWidth - 14, canvasHeight / 2);
            ctx.rotate(Math.PI / 2);
            ctx.textAlign = 'center';
            ctx.fillText(getNeighborName(1, 0) + ' ‚Üí', 0, 0);
            ctx.restore();

            // Top arrow - arrow ABOVE the neighborhood name
            ctx.textAlign = 'center';
            ctx.fillText('‚Üë', canvasWidth / 2, 8);
            ctx.fillText(getNeighborName(0, -1), canvasWidth / 2, 20);

            // Bottom arrow - arrow BELOW the neighborhood name
            ctx.fillText(getNeighborName(0, 1), canvasWidth / 2, canvasHeight - 20);
            ctx.fillText('‚Üì', canvasWidth / 2, canvasHeight - 8);

            // Draw landmark (2x2 emoji) if not collected
            if (!hoodState.landmarkCollected) {
                const landmarkPos = getLandmarkPosition();
                ctx.font = '48px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const lx = landmarkPos.x * gridSize + gridSize;
                const ly = landmarkPos.y * gridSize + gridSize;
                ctx.fillText(hood.landmark, lx, ly);
            }

            // Draw construction countdown warning (per-neighborhood state)
            if (hoodState.futureConstructionZone && hoodState.passengersUntilConstruction <= 3 && hoodState.passengersUntilConstruction > 0) {
                const zoneX = hoodState.futureConstructionZone.x * gridSize;
                const zoneY = hoodState.futureConstructionZone.y * gridSize;
                const zoneWidth = 4 * gridSize;
                const zoneHeight = 3 * gridSize;

                // Choose color based on countdown
                let bgColor;
                if (hoodState.passengersUntilConstruction === 3) {
                    bgColor = 'rgba(255, 200, 0, 0.6)'; // Yellow/caution
                } else if (hoodState.passengersUntilConstruction === 2) {
                    bgColor = 'rgba(255, 140, 0, 0.7)'; // Orange
                } else {
                    bgColor = 'rgba(255, 60, 60, 0.8)'; // Red
                }

                // Draw full 4x3 highlighted background
                ctx.fillStyle = bgColor;
                ctx.fillRect(zoneX, zoneY, zoneWidth, zoneHeight);

                // Draw border around the zone
                ctx.strokeStyle = hoodState.passengersUntilConstruction === 1 ? '#ff3333' :
                                  hoodState.passengersUntilConstruction === 2 ? '#ff8c00' : '#ffcc00';
                ctx.lineWidth = 3;
                ctx.strokeRect(zoneX + 1.5, zoneY + 1.5, zoneWidth - 3, zoneHeight - 3);

                const centerX = zoneX + zoneWidth / 2;
                const centerY = zoneY + zoneHeight / 2;

                // Draw "Closure in" text above the number
                ctx.font = 'bold 16px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = '#fff';
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 3;
                ctx.strokeText('Closure in', centerX, centerY - 20);
                ctx.fillText('Closure in', centerX, centerY - 20);

                // Draw countdown number in center
                ctx.font = 'bold 44px sans-serif';
                ctx.lineWidth = 4;
                ctx.strokeText(hoodState.passengersUntilConstruction.toString(), centerX, centerY + 12);
                ctx.fillText(hoodState.passengersUntilConstruction.toString(), centerX, centerY + 12);
            }

            // Draw construction zone (per-neighborhood state)
            if (hoodState.constructionZone) {
                // 4x3 emoji layout:
                // Top row: üöß üöß üöß üöß
                // Middle row: ‚ö†Ô∏è üë∑ üë∑ ‚ö†Ô∏è
                // Bottom row: üöß üöß üöß üöß
                const constructionLayout = [
                    ['üöß', 'üöß', 'üöß', 'üöß'],
                    ['‚ö†Ô∏è', 'üë∑', 'üë∑', '‚ö†Ô∏è'],
                    ['üöß', 'üöß', 'üöß', 'üöß']
                ];
                ctx.globalAlpha = hoodState.constructionFadeOpacity;

                if (hoodState.constructionShowCheckmark) {
                    // Show green checkmark
                    ctx.font = '72px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    const centerX = (hoodState.constructionZone.x + 2) * gridSize;
                    const centerY = (hoodState.constructionZone.y + 1.5) * gridSize;
                    ctx.fillText('‚úÖ', centerX, centerY);
                } else {
                    // Draw 4x3 construction zone with specific emoji layout
                    ctx.font = '24px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';

                    for (let dy = 0; dy < 3; dy++) {
                        for (let dx = 0; dx < 4; dx++) {
                            const x = (hoodState.constructionZone.x + dx) * gridSize + gridSize / 2;
                            const y = (hoodState.constructionZone.y + dy) * gridSize + gridSize / 2;
                            ctx.fillText(constructionLayout[dy][dx], x, y);
                        }
                    }
                }
                ctx.globalAlpha = 1;
            }

            // Draw car if present
            if (hoodState.car) {
                ctx.font = '22px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const carEmoji = hoodState.car.type === 'red' ? 'üöó' : 'üöô';
                const cx = hoodState.car.x * gridSize + gridSize / 2;
                const cy = hoodState.car.y * gridSize + gridSize / 2;
                ctx.fillText(carEmoji, cx, cy);
            }

            // Draw bus (pixel art style - kept as-is)
            bus.forEach((segment, index) => {
                if (index === 0) {
                    // Bus head (front) with windshield and bumper
                    ctx.fillStyle = '#E16710';
                    ctx.fillRect(
                        segment.x * gridSize + 1,
                        segment.y * gridSize + 1,
                        gridSize - 2,
                        gridSize - 2
                    );

                    // Blue windshield (top third)
                    ctx.fillStyle = '#33CCFF';
                    ctx.fillRect(
                        segment.x * gridSize + 2,
                        segment.y * gridSize + 2,
                        gridSize - 4,
                        (gridSize - 4) / 3
                    );

                    // Gray bumper (bottom quarter)
                    ctx.fillStyle = '#ADB8BF';
                    ctx.fillRect(
                        segment.x * gridSize + 2,
                        segment.y * gridSize + gridSize - 2 - (gridSize - 4) / 4,
                        gridSize - 4,
                        (gridSize - 4) / 4
                    );
                } else if (index === bus.length - 1) {
                    // Bus back with gray rectangle on bottom third
                    ctx.fillStyle = '#E16710';
                    ctx.fillRect(
                        segment.x * gridSize + 1,
                        segment.y * gridSize + 1,
                        gridSize - 2,
                        gridSize - 2
                    );

                    // Gray rectangle on bottom third
                    ctx.fillStyle = '#ADB8BF';
                    ctx.fillRect(
                        segment.x * gridSize + 2,
                        segment.y * gridSize + gridSize - 2 - (gridSize - 4) / 3,
                        gridSize - 4,
                        (gridSize - 4) / 3
                    );
                } else {
                    // Middle bus segments
                    ctx.fillStyle = '#E16710';
                    ctx.fillRect(
                        segment.x * gridSize + 1,
                        segment.y * gridSize + 1,
                        gridSize - 2,
                        gridSize - 2
                    );

                    // Add blue windows to make it look like a bus (adjusted for 25px grid)
                    ctx.fillStyle = '#33CCFF';
                    ctx.fillRect(
                        segment.x * gridSize + 5,
                        segment.y * gridSize + 5,
                        5,
                        5
                    );
                    ctx.fillRect(
                        segment.x * gridSize + gridSize - 10,
                        segment.y * gridSize + 5,
                        5,
                        5
                    );
                }
            });

            // Draw passengers using emojis
            ctx.font = '24px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            passengers.forEach(passenger => {
                const px = passenger.x * gridSize + gridSize / 2;
                const py = passenger.y * gridSize + gridSize / 2;
                ctx.fillText(passenger.emoji, px, py);
            });

            // Draw bus stops using üöè emoji
            ctx.font = '26px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            busStops.forEach(stop => {
                const sx = stop.x * gridSize + gridSize / 2;
                const sy = stop.y * gridSize + gridSize / 2;
                ctx.fillText('üöè', sx, sy);
            });
        }
        
        function updateScore() {
            document.getElementById('score').textContent = `SCORE: ${score}`;
        }
        
        function endGame() {
            gameRunning = false;
            clearInterval(gameLoop);
            
            // Save high scores
            let highScores = JSON.parse(localStorage.getItem('metroHighScores') || '[]');
            highScores.push(score);
            highScores.sort((a, b) => b - a);
            highScores = highScores.slice(0, 3);
            localStorage.setItem('metroHighScores', JSON.stringify(highScores));
            
            // Display game over
            document.getElementById('finalScore').textContent = `YOUR SCORE: ${score}`;
            
            let highScoresHTML = '<h3>TOP SCORES</h3>';
            highScores.forEach((s, i) => {
                highScoresHTML += `<p>${i + 1}. ${s}</p>`;
            });
            document.getElementById('highScores').innerHTML = highScoresHTML;
            
            document.getElementById('gameOver').style.display = 'block';
        }
        
        document.getElementById('restartBtn').addEventListener('click', initGame);

        // Start screen handler
        document.getElementById('tapToStart').addEventListener('click', function() {
            // Initialize audio context - critical for both mobile AND desktop browsers
            // This is the main user gesture that unlocks audio
            initAudio();

            // For desktop browsers, force a second resume attempt after a short delay
            // This helps with Chrome/Safari/Firefox autoplay policies
            setTimeout(() => {
                if (audioContext && audioContext.state === 'suspended') {
                    audioContext.resume().then(() => {
                        audioInitialized = true;
                        unlockAudio();
                    });
                }
            }, 100);

            // Hide start screen
            document.getElementById('startScreen').style.display = 'none';
            // Start the game
            initGame();
        });

        // Initialize neighborhood states and draw initial state without starting game loop
        initAllNeighborhoodStates();
        updateNeighborhoodDisplay();
        draw();
    </script>
</body>
</html>
